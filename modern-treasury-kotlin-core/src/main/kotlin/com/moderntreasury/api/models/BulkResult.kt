// File generated from our OpenAPI spec by Stainless.

package com.moderntreasury.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.moderntreasury.api.core.BaseDeserializer
import com.moderntreasury.api.core.BaseSerializer
import com.moderntreasury.api.core.Enum
import com.moderntreasury.api.core.ExcludeMissing
import com.moderntreasury.api.core.JsonField
import com.moderntreasury.api.core.JsonMissing
import com.moderntreasury.api.core.JsonValue
import com.moderntreasury.api.core.NoAutoDetect
import com.moderntreasury.api.core.checkKnown
import com.moderntreasury.api.core.checkRequired
import com.moderntreasury.api.core.getOrThrow
import com.moderntreasury.api.core.immutableEmptyMap
import com.moderntreasury.api.core.toImmutable
import com.moderntreasury.api.errors.ModernTreasuryInvalidDataException
import java.time.OffsetDateTime
import java.util.Objects

@NoAutoDetect
class BulkResult
@JsonCreator
private constructor(
    @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
    @JsonProperty("created_at")
    @ExcludeMissing
    private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
    @JsonProperty("entity")
    @ExcludeMissing
    private val entity: JsonField<Entity> = JsonMissing.of(),
    @JsonProperty("entity_id")
    @ExcludeMissing
    private val entityId: JsonField<String> = JsonMissing.of(),
    @JsonProperty("entity_type")
    @ExcludeMissing
    private val entityType: JsonField<EntityType> = JsonMissing.of(),
    @JsonProperty("live_mode")
    @ExcludeMissing
    private val liveMode: JsonField<Boolean> = JsonMissing.of(),
    @JsonProperty("object")
    @ExcludeMissing
    private val object_: JsonField<String> = JsonMissing.of(),
    @JsonProperty("request_id")
    @ExcludeMissing
    private val requestId: JsonField<String> = JsonMissing.of(),
    @JsonProperty("request_params")
    @ExcludeMissing
    private val requestParams: JsonField<RequestParams> = JsonMissing.of(),
    @JsonProperty("request_type")
    @ExcludeMissing
    private val requestType: JsonField<RequestType> = JsonMissing.of(),
    @JsonProperty("status")
    @ExcludeMissing
    private val status: JsonField<Status> = JsonMissing.of(),
    @JsonProperty("updated_at")
    @ExcludeMissing
    private val updatedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
    @JsonAnySetter private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
) {

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun id(): String = id.getRequired("id")

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

    /**
     * An object with type as indicated by `entity_type`. This is the result object that is
     * generated by performing the requested action on the provided input `request_params`.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun entity(): Entity = entity.getRequired("entity")

    /**
     * Unique identifier for the result entity object.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun entityId(): String = entityId.getRequired("entity_id")

    /**
     * The type of the result entity object. For a successful bulk result, this is the same as the
     * `resource_type` of the bulk request. For a failed bulk result, this is always bulk_error
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun entityType(): EntityType = entityType.getRequired("entity_type")

    /**
     * This field will be true if this object exists in the live environment or false if it exists
     * in the test environment.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun liveMode(): Boolean = liveMode.getRequired("live_mode")

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun object_(): String = object_.getRequired("object")

    /**
     * Unique identifier for the request that created this bulk result. This is the ID of the bulk
     * request when `request_type` is bulk_request
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun requestId(): String = requestId.getRequired("request_id")

    /**
     * An optional object that contains the provided input params for the request that created this
     * result. This is an item in the `resources` array for the bulk_request
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type (e.g. if
     *   the server responded with an unexpected value).
     */
    fun requestParams(): RequestParams? = requestParams.getNullable("request_params")

    /**
     * The type of the request that created this result. bulk_request is the only supported
     * `request_type`
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun requestType(): RequestType = requestType.getRequired("request_type")

    /**
     * One of successful or failed.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun status(): Status = status.getRequired("status")

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun updatedAt(): OffsetDateTime = updatedAt.getRequired("updated_at")

    /**
     * Returns the raw JSON value of [id].
     *
     * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

    /**
     * Returns the raw JSON value of [createdAt].
     *
     * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("created_at")
    @ExcludeMissing
    fun _createdAt(): JsonField<OffsetDateTime> = createdAt

    /**
     * Returns the raw JSON value of [entity].
     *
     * Unlike [entity], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("entity") @ExcludeMissing fun _entity(): JsonField<Entity> = entity

    /**
     * Returns the raw JSON value of [entityId].
     *
     * Unlike [entityId], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("entity_id") @ExcludeMissing fun _entityId(): JsonField<String> = entityId

    /**
     * Returns the raw JSON value of [entityType].
     *
     * Unlike [entityType], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("entity_type")
    @ExcludeMissing
    fun _entityType(): JsonField<EntityType> = entityType

    /**
     * Returns the raw JSON value of [liveMode].
     *
     * Unlike [liveMode], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("live_mode") @ExcludeMissing fun _liveMode(): JsonField<Boolean> = liveMode

    /**
     * Returns the raw JSON value of [object_].
     *
     * Unlike [object_], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("object") @ExcludeMissing fun _object_(): JsonField<String> = object_

    /**
     * Returns the raw JSON value of [requestId].
     *
     * Unlike [requestId], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("request_id") @ExcludeMissing fun _requestId(): JsonField<String> = requestId

    /**
     * Returns the raw JSON value of [requestParams].
     *
     * Unlike [requestParams], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("request_params")
    @ExcludeMissing
    fun _requestParams(): JsonField<RequestParams> = requestParams

    /**
     * Returns the raw JSON value of [requestType].
     *
     * Unlike [requestType], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("request_type")
    @ExcludeMissing
    fun _requestType(): JsonField<RequestType> = requestType

    /**
     * Returns the raw JSON value of [status].
     *
     * Unlike [status], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("status") @ExcludeMissing fun _status(): JsonField<Status> = status

    /**
     * Returns the raw JSON value of [updatedAt].
     *
     * Unlike [updatedAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("updated_at")
    @ExcludeMissing
    fun _updatedAt(): JsonField<OffsetDateTime> = updatedAt

    @JsonAnyGetter
    @ExcludeMissing
    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

    private var validated: Boolean = false

    fun validate(): BulkResult = apply {
        if (validated) {
            return@apply
        }

        id()
        createdAt()
        entity().validate()
        entityId()
        entityType()
        liveMode()
        object_()
        requestId()
        requestParams()?.validate()
        requestType()
        status()
        updatedAt()
        validated = true
    }

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of [BulkResult].
         *
         * The following fields are required:
         * ```kotlin
         * .id()
         * .createdAt()
         * .entity()
         * .entityId()
         * .entityType()
         * .liveMode()
         * .object_()
         * .requestId()
         * .requestParams()
         * .requestType()
         * .status()
         * .updatedAt()
         * ```
         */
        fun builder() = Builder()
    }

    /** A builder for [BulkResult]. */
    class Builder internal constructor() {

        private var id: JsonField<String>? = null
        private var createdAt: JsonField<OffsetDateTime>? = null
        private var entity: JsonField<Entity>? = null
        private var entityId: JsonField<String>? = null
        private var entityType: JsonField<EntityType>? = null
        private var liveMode: JsonField<Boolean>? = null
        private var object_: JsonField<String>? = null
        private var requestId: JsonField<String>? = null
        private var requestParams: JsonField<RequestParams>? = null
        private var requestType: JsonField<RequestType>? = null
        private var status: JsonField<Status>? = null
        private var updatedAt: JsonField<OffsetDateTime>? = null
        private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

        internal fun from(bulkResult: BulkResult) = apply {
            id = bulkResult.id
            createdAt = bulkResult.createdAt
            entity = bulkResult.entity
            entityId = bulkResult.entityId
            entityType = bulkResult.entityType
            liveMode = bulkResult.liveMode
            object_ = bulkResult.object_
            requestId = bulkResult.requestId
            requestParams = bulkResult.requestParams
            requestType = bulkResult.requestType
            status = bulkResult.status
            updatedAt = bulkResult.updatedAt
            additionalProperties = bulkResult.additionalProperties.toMutableMap()
        }

        fun id(id: String) = id(JsonField.of(id))

        /**
         * Sets [Builder.id] to an arbitrary JSON value.
         *
         * You should usually call [Builder.id] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun id(id: JsonField<String>) = apply { this.id = id }

        fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

        /**
         * Sets [Builder.createdAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply { this.createdAt = createdAt }

        /**
         * An object with type as indicated by `entity_type`. This is the result object that is
         * generated by performing the requested action on the provided input `request_params`.
         */
        fun entity(entity: Entity) = entity(JsonField.of(entity))

        /**
         * Sets [Builder.entity] to an arbitrary JSON value.
         *
         * You should usually call [Builder.entity] with a well-typed [Entity] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun entity(entity: JsonField<Entity>) = apply { this.entity = entity }

        /** Alias for calling [entity] with `Entity.ofPaymentOrder(paymentOrder)`. */
        fun entity(paymentOrder: PaymentOrder) = entity(Entity.ofPaymentOrder(paymentOrder))

        /** Alias for calling [entity] with `Entity.ofExpectedPayment(expectedPayment)`. */
        fun entity(expectedPayment: ExpectedPayment) =
            entity(Entity.ofExpectedPayment(expectedPayment))

        /** Alias for calling [entity] with `Entity.ofLedgerTransaction(ledgerTransaction)`. */
        fun entity(ledgerTransaction: LedgerTransaction) =
            entity(Entity.ofLedgerTransaction(ledgerTransaction))

        /** Alias for calling [entity] with `Entity.ofTransaction(transaction)`. */
        fun entity(transaction: Transaction) = entity(Entity.ofTransaction(transaction))

        /** Alias for calling [entity] with `Entity.ofBulkError(bulkError)`. */
        fun entity(bulkError: Entity.BulkError) = entity(Entity.ofBulkError(bulkError))

        /** Unique identifier for the result entity object. */
        fun entityId(entityId: String) = entityId(JsonField.of(entityId))

        /**
         * Sets [Builder.entityId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.entityId] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun entityId(entityId: JsonField<String>) = apply { this.entityId = entityId }

        /**
         * The type of the result entity object. For a successful bulk result, this is the same as
         * the `resource_type` of the bulk request. For a failed bulk result, this is always
         * bulk_error
         */
        fun entityType(entityType: EntityType) = entityType(JsonField.of(entityType))

        /**
         * Sets [Builder.entityType] to an arbitrary JSON value.
         *
         * You should usually call [Builder.entityType] with a well-typed [EntityType] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun entityType(entityType: JsonField<EntityType>) = apply { this.entityType = entityType }

        /**
         * This field will be true if this object exists in the live environment or false if it
         * exists in the test environment.
         */
        fun liveMode(liveMode: Boolean) = liveMode(JsonField.of(liveMode))

        /**
         * Sets [Builder.liveMode] to an arbitrary JSON value.
         *
         * You should usually call [Builder.liveMode] with a well-typed [Boolean] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun liveMode(liveMode: JsonField<Boolean>) = apply { this.liveMode = liveMode }

        fun object_(object_: String) = object_(JsonField.of(object_))

        /**
         * Sets [Builder.object_] to an arbitrary JSON value.
         *
         * You should usually call [Builder.object_] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun object_(object_: JsonField<String>) = apply { this.object_ = object_ }

        /**
         * Unique identifier for the request that created this bulk result. This is the ID of the
         * bulk request when `request_type` is bulk_request
         */
        fun requestId(requestId: String) = requestId(JsonField.of(requestId))

        /**
         * Sets [Builder.requestId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.requestId] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun requestId(requestId: JsonField<String>) = apply { this.requestId = requestId }

        /**
         * An optional object that contains the provided input params for the request that created
         * this result. This is an item in the `resources` array for the bulk_request
         */
        fun requestParams(requestParams: RequestParams?) =
            requestParams(JsonField.ofNullable(requestParams))

        /**
         * Sets [Builder.requestParams] to an arbitrary JSON value.
         *
         * You should usually call [Builder.requestParams] with a well-typed [RequestParams] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun requestParams(requestParams: JsonField<RequestParams>) = apply {
            this.requestParams = requestParams
        }

        /**
         * The type of the request that created this result. bulk_request is the only supported
         * `request_type`
         */
        fun requestType(requestType: RequestType) = requestType(JsonField.of(requestType))

        /**
         * Sets [Builder.requestType] to an arbitrary JSON value.
         *
         * You should usually call [Builder.requestType] with a well-typed [RequestType] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun requestType(requestType: JsonField<RequestType>) = apply {
            this.requestType = requestType
        }

        /** One of successful or failed. */
        fun status(status: Status) = status(JsonField.of(status))

        /**
         * Sets [Builder.status] to an arbitrary JSON value.
         *
         * You should usually call [Builder.status] with a well-typed [Status] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun status(status: JsonField<Status>) = apply { this.status = status }

        fun updatedAt(updatedAt: OffsetDateTime) = updatedAt(JsonField.of(updatedAt))

        /**
         * Sets [Builder.updatedAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.updatedAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun updatedAt(updatedAt: JsonField<OffsetDateTime>) = apply { this.updatedAt = updatedAt }

        fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.clear()
            putAllAdditionalProperties(additionalProperties)
        }

        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
            additionalProperties.put(key, value)
        }

        fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.putAll(additionalProperties)
        }

        fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
            keys.forEach(::removeAdditionalProperty)
        }

        fun build(): BulkResult =
            BulkResult(
                checkRequired("id", id),
                checkRequired("createdAt", createdAt),
                checkRequired("entity", entity),
                checkRequired("entityId", entityId),
                checkRequired("entityType", entityType),
                checkRequired("liveMode", liveMode),
                checkRequired("object_", object_),
                checkRequired("requestId", requestId),
                checkRequired("requestParams", requestParams),
                checkRequired("requestType", requestType),
                checkRequired("status", status),
                checkRequired("updatedAt", updatedAt),
                additionalProperties.toImmutable(),
            )
    }

    /**
     * An object with type as indicated by `entity_type`. This is the result object that is
     * generated by performing the requested action on the provided input `request_params`.
     */
    @JsonDeserialize(using = Entity.Deserializer::class)
    @JsonSerialize(using = Entity.Serializer::class)
    class Entity
    private constructor(
        private val paymentOrder: PaymentOrder? = null,
        private val expectedPayment: ExpectedPayment? = null,
        private val ledgerTransaction: LedgerTransaction? = null,
        private val transaction: Transaction? = null,
        private val bulkError: BulkError? = null,
        private val _json: JsonValue? = null,
    ) {

        fun paymentOrder(): PaymentOrder? = paymentOrder

        fun expectedPayment(): ExpectedPayment? = expectedPayment

        fun ledgerTransaction(): LedgerTransaction? = ledgerTransaction

        fun transaction(): Transaction? = transaction

        fun bulkError(): BulkError? = bulkError

        fun isPaymentOrder(): Boolean = paymentOrder != null

        fun isExpectedPayment(): Boolean = expectedPayment != null

        fun isLedgerTransaction(): Boolean = ledgerTransaction != null

        fun isTransaction(): Boolean = transaction != null

        fun isBulkError(): Boolean = bulkError != null

        fun asPaymentOrder(): PaymentOrder = paymentOrder.getOrThrow("paymentOrder")

        fun asExpectedPayment(): ExpectedPayment = expectedPayment.getOrThrow("expectedPayment")

        fun asLedgerTransaction(): LedgerTransaction =
            ledgerTransaction.getOrThrow("ledgerTransaction")

        fun asTransaction(): Transaction = transaction.getOrThrow("transaction")

        fun asBulkError(): BulkError = bulkError.getOrThrow("bulkError")

        fun _json(): JsonValue? = _json

        fun <T> accept(visitor: Visitor<T>): T {
            return when {
                paymentOrder != null -> visitor.visitPaymentOrder(paymentOrder)
                expectedPayment != null -> visitor.visitExpectedPayment(expectedPayment)
                ledgerTransaction != null -> visitor.visitLedgerTransaction(ledgerTransaction)
                transaction != null -> visitor.visitTransaction(transaction)
                bulkError != null -> visitor.visitBulkError(bulkError)
                else -> visitor.unknown(_json)
            }
        }

        private var validated: Boolean = false

        fun validate(): Entity = apply {
            if (validated) {
                return@apply
            }

            accept(
                object : Visitor<Unit> {
                    override fun visitPaymentOrder(paymentOrder: PaymentOrder) {
                        paymentOrder.validate()
                    }

                    override fun visitExpectedPayment(expectedPayment: ExpectedPayment) {
                        expectedPayment.validate()
                    }

                    override fun visitLedgerTransaction(ledgerTransaction: LedgerTransaction) {
                        ledgerTransaction.validate()
                    }

                    override fun visitTransaction(transaction: Transaction) {
                        transaction.validate()
                    }

                    override fun visitBulkError(bulkError: BulkError) {
                        bulkError.validate()
                    }
                }
            )
            validated = true
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Entity && paymentOrder == other.paymentOrder && expectedPayment == other.expectedPayment && ledgerTransaction == other.ledgerTransaction && transaction == other.transaction && bulkError == other.bulkError /* spotless:on */
        }

        override fun hashCode(): Int = /* spotless:off */ Objects.hash(paymentOrder, expectedPayment, ledgerTransaction, transaction, bulkError) /* spotless:on */

        override fun toString(): String =
            when {
                paymentOrder != null -> "Entity{paymentOrder=$paymentOrder}"
                expectedPayment != null -> "Entity{expectedPayment=$expectedPayment}"
                ledgerTransaction != null -> "Entity{ledgerTransaction=$ledgerTransaction}"
                transaction != null -> "Entity{transaction=$transaction}"
                bulkError != null -> "Entity{bulkError=$bulkError}"
                _json != null -> "Entity{_unknown=$_json}"
                else -> throw IllegalStateException("Invalid Entity")
            }

        companion object {

            fun ofPaymentOrder(paymentOrder: PaymentOrder) = Entity(paymentOrder = paymentOrder)

            fun ofExpectedPayment(expectedPayment: ExpectedPayment) =
                Entity(expectedPayment = expectedPayment)

            fun ofLedgerTransaction(ledgerTransaction: LedgerTransaction) =
                Entity(ledgerTransaction = ledgerTransaction)

            fun ofTransaction(transaction: Transaction) = Entity(transaction = transaction)

            fun ofBulkError(bulkError: BulkError) = Entity(bulkError = bulkError)
        }

        /** An interface that defines how to map each variant of [Entity] to a value of type [T]. */
        interface Visitor<out T> {

            fun visitPaymentOrder(paymentOrder: PaymentOrder): T

            fun visitExpectedPayment(expectedPayment: ExpectedPayment): T

            fun visitLedgerTransaction(ledgerTransaction: LedgerTransaction): T

            fun visitTransaction(transaction: Transaction): T

            fun visitBulkError(bulkError: BulkError): T

            /**
             * Maps an unknown variant of [Entity] to a value of type [T].
             *
             * An instance of [Entity] can contain an unknown variant if it was deserialized from
             * data that doesn't match any known variant. For example, if the SDK is on an older
             * version than the API, then the API may respond with new variants that the SDK is
             * unaware of.
             *
             * @throws ModernTreasuryInvalidDataException in the default implementation.
             */
            fun unknown(json: JsonValue?): T {
                throw ModernTreasuryInvalidDataException("Unknown Entity: $json")
            }
        }

        internal class Deserializer : BaseDeserializer<Entity>(Entity::class) {

            override fun ObjectCodec.deserialize(node: JsonNode): Entity {
                val json = JsonValue.fromJsonNode(node)

                tryDeserialize(node, jacksonTypeRef<PaymentOrder>()) { it.validate() }
                    ?.let {
                        return Entity(paymentOrder = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<ExpectedPayment>()) { it.validate() }
                    ?.let {
                        return Entity(expectedPayment = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<LedgerTransaction>()) { it.validate() }
                    ?.let {
                        return Entity(ledgerTransaction = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<Transaction>()) { it.validate() }
                    ?.let {
                        return Entity(transaction = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<BulkError>()) { it.validate() }
                    ?.let {
                        return Entity(bulkError = it, _json = json)
                    }

                return Entity(_json = json)
            }
        }

        internal class Serializer : BaseSerializer<Entity>(Entity::class) {

            override fun serialize(
                value: Entity,
                generator: JsonGenerator,
                provider: SerializerProvider,
            ) {
                when {
                    value.paymentOrder != null -> generator.writeObject(value.paymentOrder)
                    value.expectedPayment != null -> generator.writeObject(value.expectedPayment)
                    value.ledgerTransaction != null ->
                        generator.writeObject(value.ledgerTransaction)
                    value.transaction != null -> generator.writeObject(value.transaction)
                    value.bulkError != null -> generator.writeObject(value.bulkError)
                    value._json != null -> generator.writeObject(value._json)
                    else -> throw IllegalStateException("Invalid Entity")
                }
            }
        }

        @NoAutoDetect
        class BulkError
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("live_mode")
            @ExcludeMissing
            private val liveMode: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("object")
            @ExcludeMissing
            private val object_: JsonField<String> = JsonMissing.of(),
            @JsonProperty("request_errors")
            @ExcludeMissing
            private val requestErrors: JsonField<List<RequestError>> = JsonMissing.of(),
            @JsonProperty("updated_at")
            @ExcludeMissing
            private val updatedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

            /**
             * This field will be true if this object exists in the live environment or false if it
             * exists in the test environment.
             *
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun liveMode(): Boolean = liveMode.getRequired("live_mode")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun object_(): String = object_.getRequired("object")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun requestErrors(): List<RequestError> = requestErrors.getRequired("request_errors")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun updatedAt(): OffsetDateTime = updatedAt.getRequired("updated_at")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [createdAt].
             *
             * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("created_at")
            @ExcludeMissing
            fun _createdAt(): JsonField<OffsetDateTime> = createdAt

            /**
             * Returns the raw JSON value of [liveMode].
             *
             * Unlike [liveMode], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("live_mode")
            @ExcludeMissing
            fun _liveMode(): JsonField<Boolean> = liveMode

            /**
             * Returns the raw JSON value of [object_].
             *
             * Unlike [object_], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("object") @ExcludeMissing fun _object_(): JsonField<String> = object_

            /**
             * Returns the raw JSON value of [requestErrors].
             *
             * Unlike [requestErrors], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("request_errors")
            @ExcludeMissing
            fun _requestErrors(): JsonField<List<RequestError>> = requestErrors

            /**
             * Returns the raw JSON value of [updatedAt].
             *
             * Unlike [updatedAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("updated_at")
            @ExcludeMissing
            fun _updatedAt(): JsonField<OffsetDateTime> = updatedAt

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BulkError = apply {
                if (validated) {
                    return@apply
                }

                id()
                createdAt()
                liveMode()
                object_()
                requestErrors().forEach { it.validate() }
                updatedAt()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BulkError].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .id()
                 * .createdAt()
                 * .liveMode()
                 * .object_()
                 * .requestErrors()
                 * .updatedAt()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [BulkError]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var createdAt: JsonField<OffsetDateTime>? = null
                private var liveMode: JsonField<Boolean>? = null
                private var object_: JsonField<String>? = null
                private var requestErrors: JsonField<MutableList<RequestError>>? = null
                private var updatedAt: JsonField<OffsetDateTime>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(bulkError: BulkError) = apply {
                    id = bulkError.id
                    createdAt = bulkError.createdAt
                    liveMode = bulkError.liveMode
                    object_ = bulkError.object_
                    requestErrors = bulkError.requestErrors.map { it.toMutableList() }
                    updatedAt = bulkError.updatedAt
                    additionalProperties = bulkError.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

                /**
                 * Sets [Builder.createdAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                    this.createdAt = createdAt
                }

                /**
                 * This field will be true if this object exists in the live environment or false if
                 * it exists in the test environment.
                 */
                fun liveMode(liveMode: Boolean) = liveMode(JsonField.of(liveMode))

                /**
                 * Sets [Builder.liveMode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.liveMode] with a well-typed [Boolean] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun liveMode(liveMode: JsonField<Boolean>) = apply { this.liveMode = liveMode }

                fun object_(object_: String) = object_(JsonField.of(object_))

                /**
                 * Sets [Builder.object_] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.object_] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun object_(object_: JsonField<String>) = apply { this.object_ = object_ }

                fun requestErrors(requestErrors: List<RequestError>) =
                    requestErrors(JsonField.of(requestErrors))

                /**
                 * Sets [Builder.requestErrors] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.requestErrors] with a well-typed
                 * `List<RequestError>` value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun requestErrors(requestErrors: JsonField<List<RequestError>>) = apply {
                    this.requestErrors = requestErrors.map { it.toMutableList() }
                }

                /**
                 * Adds a single [RequestError] to [requestErrors].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addRequestError(requestError: RequestError) = apply {
                    requestErrors =
                        (requestErrors ?: JsonField.of(mutableListOf())).also {
                            checkKnown("requestErrors", it).add(requestError)
                        }
                }

                fun updatedAt(updatedAt: OffsetDateTime) = updatedAt(JsonField.of(updatedAt))

                /**
                 * Sets [Builder.updatedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.updatedAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun updatedAt(updatedAt: JsonField<OffsetDateTime>) = apply {
                    this.updatedAt = updatedAt
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BulkError =
                    BulkError(
                        checkRequired("id", id),
                        checkRequired("createdAt", createdAt),
                        checkRequired("liveMode", liveMode),
                        checkRequired("object_", object_),
                        checkRequired("requestErrors", requestErrors).map { it.toImmutable() },
                        checkRequired("updatedAt", updatedAt),
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class RequestError
            @JsonCreator
            private constructor(
                @JsonProperty("code")
                @ExcludeMissing
                private val code: JsonField<String> = JsonMissing.of(),
                @JsonProperty("message")
                @ExcludeMissing
                private val message: JsonField<String> = JsonMissing.of(),
                @JsonProperty("parameter")
                @ExcludeMissing
                private val parameter: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected
                 *   type (e.g. if the server responded with an unexpected value).
                 */
                fun code(): String? = code.getNullable("code")

                /**
                 * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected
                 *   type (e.g. if the server responded with an unexpected value).
                 */
                fun message(): String? = message.getNullable("message")

                /**
                 * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected
                 *   type (e.g. if the server responded with an unexpected value).
                 */
                fun parameter(): String? = parameter.getNullable("parameter")

                /**
                 * Returns the raw JSON value of [code].
                 *
                 * Unlike [code], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("code") @ExcludeMissing fun _code(): JsonField<String> = code

                /**
                 * Returns the raw JSON value of [message].
                 *
                 * Unlike [message], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("message") @ExcludeMissing fun _message(): JsonField<String> = message

                /**
                 * Returns the raw JSON value of [parameter].
                 *
                 * Unlike [parameter], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("parameter")
                @ExcludeMissing
                fun _parameter(): JsonField<String> = parameter

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): RequestError = apply {
                    if (validated) {
                        return@apply
                    }

                    code()
                    message()
                    parameter()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    /** Returns a mutable builder for constructing an instance of [RequestError]. */
                    fun builder() = Builder()
                }

                /** A builder for [RequestError]. */
                class Builder internal constructor() {

                    private var code: JsonField<String> = JsonMissing.of()
                    private var message: JsonField<String> = JsonMissing.of()
                    private var parameter: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(requestError: RequestError) = apply {
                        code = requestError.code
                        message = requestError.message
                        parameter = requestError.parameter
                        additionalProperties = requestError.additionalProperties.toMutableMap()
                    }

                    fun code(code: String) = code(JsonField.of(code))

                    /**
                     * Sets [Builder.code] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.code] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun code(code: JsonField<String>) = apply { this.code = code }

                    fun message(message: String) = message(JsonField.of(message))

                    /**
                     * Sets [Builder.message] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.message] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun message(message: JsonField<String>) = apply { this.message = message }

                    fun parameter(parameter: String) = parameter(JsonField.of(parameter))

                    /**
                     * Sets [Builder.parameter] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.parameter] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun parameter(parameter: JsonField<String>) = apply {
                        this.parameter = parameter
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): RequestError =
                        RequestError(code, message, parameter, additionalProperties.toImmutable())
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is RequestError && code == other.code && message == other.message && parameter == other.parameter && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(code, message, parameter, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "RequestError{code=$code, message=$message, parameter=$parameter, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkError && id == other.id && createdAt == other.createdAt && liveMode == other.liveMode && object_ == other.object_ && requestErrors == other.requestErrors && updatedAt == other.updatedAt && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, createdAt, liveMode, object_, requestErrors, updatedAt, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkError{id=$id, createdAt=$createdAt, liveMode=$liveMode, object_=$object_, requestErrors=$requestErrors, updatedAt=$updatedAt, additionalProperties=$additionalProperties}"
        }
    }

    /**
     * The type of the result entity object. For a successful bulk result, this is the same as the
     * `resource_type` of the bulk request. For a failed bulk result, this is always bulk_error
     */
    class EntityType @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val PAYMENT_ORDER = of("payment_order")

            val LEDGER_TRANSACTION = of("ledger_transaction")

            val TRANSACTION = of("transaction")

            val EXPECTED_PAYMENT = of("expected_payment")

            val BULK_ERROR = of("bulk_error")

            fun of(value: String) = EntityType(JsonField.of(value))
        }

        /** An enum containing [EntityType]'s known values. */
        enum class Known {
            PAYMENT_ORDER,
            LEDGER_TRANSACTION,
            TRANSACTION,
            EXPECTED_PAYMENT,
            BULK_ERROR,
        }

        /**
         * An enum containing [EntityType]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [EntityType] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            PAYMENT_ORDER,
            LEDGER_TRANSACTION,
            TRANSACTION,
            EXPECTED_PAYMENT,
            BULK_ERROR,
            /**
             * An enum member indicating that [EntityType] was instantiated with an unknown value.
             */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                PAYMENT_ORDER -> Value.PAYMENT_ORDER
                LEDGER_TRANSACTION -> Value.LEDGER_TRANSACTION
                TRANSACTION -> Value.TRANSACTION
                EXPECTED_PAYMENT -> Value.EXPECTED_PAYMENT
                BULK_ERROR -> Value.BULK_ERROR
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                PAYMENT_ORDER -> Known.PAYMENT_ORDER
                LEDGER_TRANSACTION -> Known.LEDGER_TRANSACTION
                TRANSACTION -> Known.TRANSACTION
                EXPECTED_PAYMENT -> Known.EXPECTED_PAYMENT
                BULK_ERROR -> Known.BULK_ERROR
                else -> throw ModernTreasuryInvalidDataException("Unknown EntityType: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value does not have
         *   the expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw ModernTreasuryInvalidDataException("Value is not a String")

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is EntityType && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /**
     * An optional object that contains the provided input params for the request that created this
     * result. This is an item in the `resources` array for the bulk_request
     */
    @NoAutoDetect
    class RequestParams
    @JsonCreator
    private constructor(
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
    ) {

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): RequestParams = apply {
            if (validated) {
                return@apply
            }

            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /** Returns a mutable builder for constructing an instance of [RequestParams]. */
            fun builder() = Builder()
        }

        /** A builder for [RequestParams]. */
        class Builder internal constructor() {

            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(requestParams: RequestParams) = apply {
                additionalProperties = requestParams.additionalProperties.toMutableMap()
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): RequestParams = RequestParams(additionalProperties.toImmutable())
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is RequestParams && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() = "RequestParams{additionalProperties=$additionalProperties}"
    }

    /**
     * The type of the request that created this result. bulk_request is the only supported
     * `request_type`
     */
    class RequestType @JsonCreator private constructor(private val value: JsonField<String>) :
        Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val BULK_REQUEST = of("bulk_request")

            fun of(value: String) = RequestType(JsonField.of(value))
        }

        /** An enum containing [RequestType]'s known values. */
        enum class Known {
            BULK_REQUEST
        }

        /**
         * An enum containing [RequestType]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [RequestType] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            BULK_REQUEST,
            /**
             * An enum member indicating that [RequestType] was instantiated with an unknown value.
             */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                BULK_REQUEST -> Value.BULK_REQUEST
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                BULK_REQUEST -> Known.BULK_REQUEST
                else -> throw ModernTreasuryInvalidDataException("Unknown RequestType: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value does not have
         *   the expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw ModernTreasuryInvalidDataException("Value is not a String")

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is RequestType && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /** One of successful or failed. */
    class Status @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val PENDING = of("pending")

            val SUCCESSFUL = of("successful")

            val FAILED = of("failed")

            fun of(value: String) = Status(JsonField.of(value))
        }

        /** An enum containing [Status]'s known values. */
        enum class Known {
            PENDING,
            SUCCESSFUL,
            FAILED,
        }

        /**
         * An enum containing [Status]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Status] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            PENDING,
            SUCCESSFUL,
            FAILED,
            /** An enum member indicating that [Status] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                PENDING -> Value.PENDING
                SUCCESSFUL -> Value.SUCCESSFUL
                FAILED -> Value.FAILED
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                PENDING -> Known.PENDING
                SUCCESSFUL -> Known.SUCCESSFUL
                FAILED -> Known.FAILED
                else -> throw ModernTreasuryInvalidDataException("Unknown Status: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value does not have
         *   the expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw ModernTreasuryInvalidDataException("Value is not a String")

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Status && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is BulkResult && id == other.id && createdAt == other.createdAt && entity == other.entity && entityId == other.entityId && entityType == other.entityType && liveMode == other.liveMode && object_ == other.object_ && requestId == other.requestId && requestParams == other.requestParams && requestType == other.requestType && status == other.status && updatedAt == other.updatedAt && additionalProperties == other.additionalProperties /* spotless:on */
    }

    /* spotless:off */
    private val hashCode: Int by lazy { Objects.hash(id, createdAt, entity, entityId, entityType, liveMode, object_, requestId, requestParams, requestType, status, updatedAt, additionalProperties) }
    /* spotless:on */

    override fun hashCode(): Int = hashCode

    override fun toString() =
        "BulkResult{id=$id, createdAt=$createdAt, entity=$entity, entityId=$entityId, entityType=$entityType, liveMode=$liveMode, object_=$object_, requestId=$requestId, requestParams=$requestParams, requestType=$requestType, status=$status, updatedAt=$updatedAt, additionalProperties=$additionalProperties}"
}
