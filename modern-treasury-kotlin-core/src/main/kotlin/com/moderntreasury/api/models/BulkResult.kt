// File generated from our OpenAPI spec by Stainless.

package com.moderntreasury.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.moderntreasury.api.core.BaseDeserializer
import com.moderntreasury.api.core.BaseSerializer
import com.moderntreasury.api.core.Enum
import com.moderntreasury.api.core.ExcludeMissing
import com.moderntreasury.api.core.JsonField
import com.moderntreasury.api.core.JsonMissing
import com.moderntreasury.api.core.JsonValue
import com.moderntreasury.api.core.NoAutoDetect
import com.moderntreasury.api.core.getOrThrow
import com.moderntreasury.api.core.toImmutable
import com.moderntreasury.api.errors.ModernTreasuryInvalidDataException
import java.time.OffsetDateTime
import java.util.Objects

@JsonDeserialize(builder = BulkResult.Builder::class)
@NoAutoDetect
class BulkResult
private constructor(
    private val id: JsonField<String>,
    private val object_: JsonField<String>,
    private val liveMode: JsonField<Boolean>,
    private val createdAt: JsonField<OffsetDateTime>,
    private val updatedAt: JsonField<OffsetDateTime>,
    private val requestId: JsonField<String>,
    private val requestType: JsonField<RequestType>,
    private val status: JsonField<Status>,
    private val requestParams: JsonField<RequestParams>,
    private val entityId: JsonField<String>,
    private val entityType: JsonField<EntityType>,
    private val entity: JsonField<Entity>,
    private val additionalProperties: Map<String, JsonValue>,
) {

    private var validated: Boolean = false

    fun id(): String = id.getRequired("id")

    fun object_(): String = object_.getRequired("object")

    /**
     * This field will be true if this object exists in the live environment or false if it exists
     * in the test environment.
     */
    fun liveMode(): Boolean = liveMode.getRequired("live_mode")

    fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

    fun updatedAt(): OffsetDateTime = updatedAt.getRequired("updated_at")

    /**
     * Unique identifier for the request that created this bulk result. This is the ID of the bulk
     * request when `request_type` is bulk_request
     */
    fun requestId(): String = requestId.getRequired("request_id")

    /**
     * The type of the request that created this result. bulk_request is the only supported
     * `request_type`
     */
    fun requestType(): RequestType = requestType.getRequired("request_type")

    /** One of successful or failed. */
    fun status(): Status = status.getRequired("status")

    /**
     * An optional object that contains the provided input params for the request that created this
     * result. This is an item in the `resources` array for the bulk_request
     */
    fun requestParams(): RequestParams? = requestParams.getNullable("request_params")

    /** Unique identifier for the result entity object. */
    fun entityId(): String = entityId.getRequired("entity_id")

    /**
     * The type of the result entity object. For a successful bulk result, this is the same as the
     * `resource_type` of the bulk request. For a failed bulk result, this is always bulk_error
     */
    fun entityType(): EntityType = entityType.getRequired("entity_type")

    /**
     * An object with type as indicated by `entity_type`. This is the result object that is
     * generated by performing the requested action on the provided input `request_params`.
     */
    fun entity(): Entity = entity.getRequired("entity")

    @JsonProperty("id") @ExcludeMissing fun _id() = id

    @JsonProperty("object") @ExcludeMissing fun _object_() = object_

    /**
     * This field will be true if this object exists in the live environment or false if it exists
     * in the test environment.
     */
    @JsonProperty("live_mode") @ExcludeMissing fun _liveMode() = liveMode

    @JsonProperty("created_at") @ExcludeMissing fun _createdAt() = createdAt

    @JsonProperty("updated_at") @ExcludeMissing fun _updatedAt() = updatedAt

    /**
     * Unique identifier for the request that created this bulk result. This is the ID of the bulk
     * request when `request_type` is bulk_request
     */
    @JsonProperty("request_id") @ExcludeMissing fun _requestId() = requestId

    /**
     * The type of the request that created this result. bulk_request is the only supported
     * `request_type`
     */
    @JsonProperty("request_type") @ExcludeMissing fun _requestType() = requestType

    /** One of successful or failed. */
    @JsonProperty("status") @ExcludeMissing fun _status() = status

    /**
     * An optional object that contains the provided input params for the request that created this
     * result. This is an item in the `resources` array for the bulk_request
     */
    @JsonProperty("request_params") @ExcludeMissing fun _requestParams() = requestParams

    /** Unique identifier for the result entity object. */
    @JsonProperty("entity_id") @ExcludeMissing fun _entityId() = entityId

    /**
     * The type of the result entity object. For a successful bulk result, this is the same as the
     * `resource_type` of the bulk request. For a failed bulk result, this is always bulk_error
     */
    @JsonProperty("entity_type") @ExcludeMissing fun _entityType() = entityType

    /**
     * An object with type as indicated by `entity_type`. This is the result object that is
     * generated by performing the requested action on the provided input `request_params`.
     */
    @JsonProperty("entity") @ExcludeMissing fun _entity() = entity

    @JsonAnyGetter
    @ExcludeMissing
    fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

    fun validate(): BulkResult = apply {
        if (!validated) {
            id()
            object_()
            liveMode()
            createdAt()
            updatedAt()
            requestId()
            requestType()
            status()
            requestParams()?.validate()
            entityId()
            entityType()
            entity()
            validated = true
        }
    }

    fun toBuilder() = Builder().from(this)

    companion object {

        fun builder() = Builder()
    }

    class Builder {

        private var id: JsonField<String> = JsonMissing.of()
        private var object_: JsonField<String> = JsonMissing.of()
        private var liveMode: JsonField<Boolean> = JsonMissing.of()
        private var createdAt: JsonField<OffsetDateTime> = JsonMissing.of()
        private var updatedAt: JsonField<OffsetDateTime> = JsonMissing.of()
        private var requestId: JsonField<String> = JsonMissing.of()
        private var requestType: JsonField<RequestType> = JsonMissing.of()
        private var status: JsonField<Status> = JsonMissing.of()
        private var requestParams: JsonField<RequestParams> = JsonMissing.of()
        private var entityId: JsonField<String> = JsonMissing.of()
        private var entityType: JsonField<EntityType> = JsonMissing.of()
        private var entity: JsonField<Entity> = JsonMissing.of()
        private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

        internal fun from(bulkResult: BulkResult) = apply {
            this.id = bulkResult.id
            this.object_ = bulkResult.object_
            this.liveMode = bulkResult.liveMode
            this.createdAt = bulkResult.createdAt
            this.updatedAt = bulkResult.updatedAt
            this.requestId = bulkResult.requestId
            this.requestType = bulkResult.requestType
            this.status = bulkResult.status
            this.requestParams = bulkResult.requestParams
            this.entityId = bulkResult.entityId
            this.entityType = bulkResult.entityType
            this.entity = bulkResult.entity
            additionalProperties(bulkResult.additionalProperties)
        }

        fun id(id: String) = id(JsonField.of(id))

        @JsonProperty("id") @ExcludeMissing fun id(id: JsonField<String>) = apply { this.id = id }

        fun object_(object_: String) = object_(JsonField.of(object_))

        @JsonProperty("object")
        @ExcludeMissing
        fun object_(object_: JsonField<String>) = apply { this.object_ = object_ }

        /**
         * This field will be true if this object exists in the live environment or false if it
         * exists in the test environment.
         */
        fun liveMode(liveMode: Boolean) = liveMode(JsonField.of(liveMode))

        /**
         * This field will be true if this object exists in the live environment or false if it
         * exists in the test environment.
         */
        @JsonProperty("live_mode")
        @ExcludeMissing
        fun liveMode(liveMode: JsonField<Boolean>) = apply { this.liveMode = liveMode }

        fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

        @JsonProperty("created_at")
        @ExcludeMissing
        fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply { this.createdAt = createdAt }

        fun updatedAt(updatedAt: OffsetDateTime) = updatedAt(JsonField.of(updatedAt))

        @JsonProperty("updated_at")
        @ExcludeMissing
        fun updatedAt(updatedAt: JsonField<OffsetDateTime>) = apply { this.updatedAt = updatedAt }

        /**
         * Unique identifier for the request that created this bulk result. This is the ID of the
         * bulk request when `request_type` is bulk_request
         */
        fun requestId(requestId: String) = requestId(JsonField.of(requestId))

        /**
         * Unique identifier for the request that created this bulk result. This is the ID of the
         * bulk request when `request_type` is bulk_request
         */
        @JsonProperty("request_id")
        @ExcludeMissing
        fun requestId(requestId: JsonField<String>) = apply { this.requestId = requestId }

        /**
         * The type of the request that created this result. bulk_request is the only supported
         * `request_type`
         */
        fun requestType(requestType: RequestType) = requestType(JsonField.of(requestType))

        /**
         * The type of the request that created this result. bulk_request is the only supported
         * `request_type`
         */
        @JsonProperty("request_type")
        @ExcludeMissing
        fun requestType(requestType: JsonField<RequestType>) = apply {
            this.requestType = requestType
        }

        /** One of successful or failed. */
        fun status(status: Status) = status(JsonField.of(status))

        /** One of successful or failed. */
        @JsonProperty("status")
        @ExcludeMissing
        fun status(status: JsonField<Status>) = apply { this.status = status }

        /**
         * An optional object that contains the provided input params for the request that created
         * this result. This is an item in the `resources` array for the bulk_request
         */
        fun requestParams(requestParams: RequestParams) = requestParams(JsonField.of(requestParams))

        /**
         * An optional object that contains the provided input params for the request that created
         * this result. This is an item in the `resources` array for the bulk_request
         */
        @JsonProperty("request_params")
        @ExcludeMissing
        fun requestParams(requestParams: JsonField<RequestParams>) = apply {
            this.requestParams = requestParams
        }

        /** Unique identifier for the result entity object. */
        fun entityId(entityId: String) = entityId(JsonField.of(entityId))

        /** Unique identifier for the result entity object. */
        @JsonProperty("entity_id")
        @ExcludeMissing
        fun entityId(entityId: JsonField<String>) = apply { this.entityId = entityId }

        /**
         * The type of the result entity object. For a successful bulk result, this is the same as
         * the `resource_type` of the bulk request. For a failed bulk result, this is always
         * bulk_error
         */
        fun entityType(entityType: EntityType) = entityType(JsonField.of(entityType))

        /**
         * The type of the result entity object. For a successful bulk result, this is the same as
         * the `resource_type` of the bulk request. For a failed bulk result, this is always
         * bulk_error
         */
        @JsonProperty("entity_type")
        @ExcludeMissing
        fun entityType(entityType: JsonField<EntityType>) = apply { this.entityType = entityType }

        /**
         * An object with type as indicated by `entity_type`. This is the result object that is
         * generated by performing the requested action on the provided input `request_params`.
         */
        fun entity(entity: Entity) = entity(JsonField.of(entity))

        /**
         * An object with type as indicated by `entity_type`. This is the result object that is
         * generated by performing the requested action on the provided input `request_params`.
         */
        @JsonProperty("entity")
        @ExcludeMissing
        fun entity(entity: JsonField<Entity>) = apply { this.entity = entity }

        fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.clear()
            this.additionalProperties.putAll(additionalProperties)
        }

        @JsonAnySetter
        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
            this.additionalProperties.put(key, value)
        }

        fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.putAll(additionalProperties)
        }

        fun build(): BulkResult =
            BulkResult(
                id,
                object_,
                liveMode,
                createdAt,
                updatedAt,
                requestId,
                requestType,
                status,
                requestParams,
                entityId,
                entityType,
                entity,
                additionalProperties.toImmutable(),
            )
    }

    @JsonDeserialize(using = Entity.Deserializer::class)
    @JsonSerialize(using = Entity.Serializer::class)
    class Entity
    private constructor(
        private val paymentOrder: PaymentOrder? = null,
        private val expectedPayment: ExpectedPayment? = null,
        private val ledgerTransaction: LedgerTransaction? = null,
        private val transaction: Transaction? = null,
        private val bulkError: BulkError? = null,
        private val _json: JsonValue? = null,
    ) {

        private var validated: Boolean = false

        fun paymentOrder(): PaymentOrder? = paymentOrder

        fun expectedPayment(): ExpectedPayment? = expectedPayment

        fun ledgerTransaction(): LedgerTransaction? = ledgerTransaction

        fun transaction(): Transaction? = transaction

        fun bulkError(): BulkError? = bulkError

        fun isPaymentOrder(): Boolean = paymentOrder != null

        fun isExpectedPayment(): Boolean = expectedPayment != null

        fun isLedgerTransaction(): Boolean = ledgerTransaction != null

        fun isTransaction(): Boolean = transaction != null

        fun isBulkError(): Boolean = bulkError != null

        fun asPaymentOrder(): PaymentOrder = paymentOrder.getOrThrow("paymentOrder")

        fun asExpectedPayment(): ExpectedPayment = expectedPayment.getOrThrow("expectedPayment")

        fun asLedgerTransaction(): LedgerTransaction =
            ledgerTransaction.getOrThrow("ledgerTransaction")

        fun asTransaction(): Transaction = transaction.getOrThrow("transaction")

        fun asBulkError(): BulkError = bulkError.getOrThrow("bulkError")

        fun _json(): JsonValue? = _json

        fun <T> accept(visitor: Visitor<T>): T {
            return when {
                paymentOrder != null -> visitor.visitPaymentOrder(paymentOrder)
                expectedPayment != null -> visitor.visitExpectedPayment(expectedPayment)
                ledgerTransaction != null -> visitor.visitLedgerTransaction(ledgerTransaction)
                transaction != null -> visitor.visitTransaction(transaction)
                bulkError != null -> visitor.visitBulkError(bulkError)
                else -> visitor.unknown(_json)
            }
        }

        fun validate(): Entity = apply {
            if (!validated) {
                if (
                    paymentOrder == null &&
                        expectedPayment == null &&
                        ledgerTransaction == null &&
                        transaction == null &&
                        bulkError == null
                ) {
                    throw ModernTreasuryInvalidDataException("Unknown Entity: $_json")
                }
                paymentOrder?.validate()
                expectedPayment?.validate()
                ledgerTransaction?.validate()
                transaction?.validate()
                bulkError?.validate()
                validated = true
            }
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Entity && paymentOrder == other.paymentOrder && expectedPayment == other.expectedPayment && ledgerTransaction == other.ledgerTransaction && transaction == other.transaction && bulkError == other.bulkError /* spotless:on */
        }

        override fun hashCode(): Int = /* spotless:off */ Objects.hash(paymentOrder, expectedPayment, ledgerTransaction, transaction, bulkError) /* spotless:on */

        override fun toString(): String =
            when {
                paymentOrder != null -> "Entity{paymentOrder=$paymentOrder}"
                expectedPayment != null -> "Entity{expectedPayment=$expectedPayment}"
                ledgerTransaction != null -> "Entity{ledgerTransaction=$ledgerTransaction}"
                transaction != null -> "Entity{transaction=$transaction}"
                bulkError != null -> "Entity{bulkError=$bulkError}"
                _json != null -> "Entity{_unknown=$_json}"
                else -> throw IllegalStateException("Invalid Entity")
            }

        companion object {

            fun ofPaymentOrder(paymentOrder: PaymentOrder) = Entity(paymentOrder = paymentOrder)

            fun ofExpectedPayment(expectedPayment: ExpectedPayment) =
                Entity(expectedPayment = expectedPayment)

            fun ofLedgerTransaction(ledgerTransaction: LedgerTransaction) =
                Entity(ledgerTransaction = ledgerTransaction)

            fun ofTransaction(transaction: Transaction) = Entity(transaction = transaction)

            fun ofBulkError(bulkError: BulkError) = Entity(bulkError = bulkError)
        }

        interface Visitor<out T> {

            fun visitPaymentOrder(paymentOrder: PaymentOrder): T

            fun visitExpectedPayment(expectedPayment: ExpectedPayment): T

            fun visitLedgerTransaction(ledgerTransaction: LedgerTransaction): T

            fun visitTransaction(transaction: Transaction): T

            fun visitBulkError(bulkError: BulkError): T

            fun unknown(json: JsonValue?): T {
                throw ModernTreasuryInvalidDataException("Unknown Entity: $json")
            }
        }

        class Deserializer : BaseDeserializer<Entity>(Entity::class) {

            override fun ObjectCodec.deserialize(node: JsonNode): Entity {
                val json = JsonValue.fromJsonNode(node)

                tryDeserialize(node, jacksonTypeRef<PaymentOrder>()) { it.validate() }
                    ?.let {
                        return Entity(paymentOrder = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<ExpectedPayment>()) { it.validate() }
                    ?.let {
                        return Entity(expectedPayment = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<LedgerTransaction>()) { it.validate() }
                    ?.let {
                        return Entity(ledgerTransaction = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<Transaction>()) { it.validate() }
                    ?.let {
                        return Entity(transaction = it, _json = json)
                    }
                tryDeserialize(node, jacksonTypeRef<BulkError>()) { it.validate() }
                    ?.let {
                        return Entity(bulkError = it, _json = json)
                    }

                return Entity(_json = json)
            }
        }

        class Serializer : BaseSerializer<Entity>(Entity::class) {

            override fun serialize(
                value: Entity,
                generator: JsonGenerator,
                provider: SerializerProvider
            ) {
                when {
                    value.paymentOrder != null -> generator.writeObject(value.paymentOrder)
                    value.expectedPayment != null -> generator.writeObject(value.expectedPayment)
                    value.ledgerTransaction != null ->
                        generator.writeObject(value.ledgerTransaction)
                    value.transaction != null -> generator.writeObject(value.transaction)
                    value.bulkError != null -> generator.writeObject(value.bulkError)
                    value._json != null -> generator.writeObject(value._json)
                    else -> throw IllegalStateException("Invalid Entity")
                }
            }
        }

        @JsonDeserialize(builder = BulkError.Builder::class)
        @NoAutoDetect
        class BulkError
        private constructor(
            private val id: JsonField<String>,
            private val object_: JsonField<String>,
            private val liveMode: JsonField<Boolean>,
            private val createdAt: JsonField<OffsetDateTime>,
            private val updatedAt: JsonField<OffsetDateTime>,
            private val requestErrors: JsonField<List<RequestError>>,
            private val additionalProperties: Map<String, JsonValue>,
        ) {

            private var validated: Boolean = false

            fun id(): String = id.getRequired("id")

            fun object_(): String = object_.getRequired("object")

            /**
             * This field will be true if this object exists in the live environment or false if it
             * exists in the test environment.
             */
            fun liveMode(): Boolean = liveMode.getRequired("live_mode")

            fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

            fun updatedAt(): OffsetDateTime = updatedAt.getRequired("updated_at")

            fun requestErrors(): List<RequestError> = requestErrors.getRequired("request_errors")

            @JsonProperty("id") @ExcludeMissing fun _id() = id

            @JsonProperty("object") @ExcludeMissing fun _object_() = object_

            /**
             * This field will be true if this object exists in the live environment or false if it
             * exists in the test environment.
             */
            @JsonProperty("live_mode") @ExcludeMissing fun _liveMode() = liveMode

            @JsonProperty("created_at") @ExcludeMissing fun _createdAt() = createdAt

            @JsonProperty("updated_at") @ExcludeMissing fun _updatedAt() = updatedAt

            @JsonProperty("request_errors") @ExcludeMissing fun _requestErrors() = requestErrors

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun validate(): BulkError = apply {
                if (!validated) {
                    id()
                    object_()
                    liveMode()
                    createdAt()
                    updatedAt()
                    requestErrors().forEach { it.validate() }
                    validated = true
                }
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                fun builder() = Builder()
            }

            class Builder {

                private var id: JsonField<String> = JsonMissing.of()
                private var object_: JsonField<String> = JsonMissing.of()
                private var liveMode: JsonField<Boolean> = JsonMissing.of()
                private var createdAt: JsonField<OffsetDateTime> = JsonMissing.of()
                private var updatedAt: JsonField<OffsetDateTime> = JsonMissing.of()
                private var requestErrors: JsonField<List<RequestError>> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(bulkError: BulkError) = apply {
                    this.id = bulkError.id
                    this.object_ = bulkError.object_
                    this.liveMode = bulkError.liveMode
                    this.createdAt = bulkError.createdAt
                    this.updatedAt = bulkError.updatedAt
                    this.requestErrors = bulkError.requestErrors
                    additionalProperties(bulkError.additionalProperties)
                }

                fun id(id: String) = id(JsonField.of(id))

                @JsonProperty("id")
                @ExcludeMissing
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun object_(object_: String) = object_(JsonField.of(object_))

                @JsonProperty("object")
                @ExcludeMissing
                fun object_(object_: JsonField<String>) = apply { this.object_ = object_ }

                /**
                 * This field will be true if this object exists in the live environment or false if
                 * it exists in the test environment.
                 */
                fun liveMode(liveMode: Boolean) = liveMode(JsonField.of(liveMode))

                /**
                 * This field will be true if this object exists in the live environment or false if
                 * it exists in the test environment.
                 */
                @JsonProperty("live_mode")
                @ExcludeMissing
                fun liveMode(liveMode: JsonField<Boolean>) = apply { this.liveMode = liveMode }

                fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

                @JsonProperty("created_at")
                @ExcludeMissing
                fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                    this.createdAt = createdAt
                }

                fun updatedAt(updatedAt: OffsetDateTime) = updatedAt(JsonField.of(updatedAt))

                @JsonProperty("updated_at")
                @ExcludeMissing
                fun updatedAt(updatedAt: JsonField<OffsetDateTime>) = apply {
                    this.updatedAt = updatedAt
                }

                fun requestErrors(requestErrors: List<RequestError>) =
                    requestErrors(JsonField.of(requestErrors))

                @JsonProperty("request_errors")
                @ExcludeMissing
                fun requestErrors(requestErrors: JsonField<List<RequestError>>) = apply {
                    this.requestErrors = requestErrors
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    this.additionalProperties.putAll(additionalProperties)
                }

                @JsonAnySetter
                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    this.additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun build(): BulkError =
                    BulkError(
                        id,
                        object_,
                        liveMode,
                        createdAt,
                        updatedAt,
                        requestErrors.map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @JsonDeserialize(builder = RequestError.Builder::class)
            @NoAutoDetect
            class RequestError
            private constructor(
                private val code: JsonField<String>,
                private val message: JsonField<String>,
                private val parameter: JsonField<String>,
                private val additionalProperties: Map<String, JsonValue>,
            ) {

                private var validated: Boolean = false

                fun code(): String? = code.getNullable("code")

                fun message(): String? = message.getNullable("message")

                fun parameter(): String? = parameter.getNullable("parameter")

                @JsonProperty("code") @ExcludeMissing fun _code() = code

                @JsonProperty("message") @ExcludeMissing fun _message() = message

                @JsonProperty("parameter") @ExcludeMissing fun _parameter() = parameter

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                fun validate(): RequestError = apply {
                    if (!validated) {
                        code()
                        message()
                        parameter()
                        validated = true
                    }
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    fun builder() = Builder()
                }

                class Builder {

                    private var code: JsonField<String> = JsonMissing.of()
                    private var message: JsonField<String> = JsonMissing.of()
                    private var parameter: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(requestError: RequestError) = apply {
                        this.code = requestError.code
                        this.message = requestError.message
                        this.parameter = requestError.parameter
                        additionalProperties(requestError.additionalProperties)
                    }

                    fun code(code: String) = code(JsonField.of(code))

                    @JsonProperty("code")
                    @ExcludeMissing
                    fun code(code: JsonField<String>) = apply { this.code = code }

                    fun message(message: String) = message(JsonField.of(message))

                    @JsonProperty("message")
                    @ExcludeMissing
                    fun message(message: JsonField<String>) = apply { this.message = message }

                    fun parameter(parameter: String) = parameter(JsonField.of(parameter))

                    @JsonProperty("parameter")
                    @ExcludeMissing
                    fun parameter(parameter: JsonField<String>) = apply {
                        this.parameter = parameter
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        this.additionalProperties.putAll(additionalProperties)
                    }

                    @JsonAnySetter
                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        this.additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun build(): RequestError =
                        RequestError(
                            code,
                            message,
                            parameter,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is RequestError && code == other.code && message == other.message && parameter == other.parameter && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(code, message, parameter, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "RequestError{code=$code, message=$message, parameter=$parameter, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkError && id == other.id && object_ == other.object_ && liveMode == other.liveMode && createdAt == other.createdAt && updatedAt == other.updatedAt && requestErrors == other.requestErrors && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, object_, liveMode, createdAt, updatedAt, requestErrors, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkError{id=$id, object_=$object_, liveMode=$liveMode, createdAt=$createdAt, updatedAt=$updatedAt, requestErrors=$requestErrors, additionalProperties=$additionalProperties}"
        }
    }

    class EntityType
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is EntityType && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            val PAYMENT_ORDER = of("payment_order")

            val LEDGER_TRANSACTION = of("ledger_transaction")

            val TRANSACTION = of("transaction")

            val EXPECTED_PAYMENT = of("expected_payment")

            val BULK_ERROR = of("bulk_error")

            fun of(value: String) = EntityType(JsonField.of(value))
        }

        enum class Known {
            PAYMENT_ORDER,
            LEDGER_TRANSACTION,
            TRANSACTION,
            EXPECTED_PAYMENT,
            BULK_ERROR,
        }

        enum class Value {
            PAYMENT_ORDER,
            LEDGER_TRANSACTION,
            TRANSACTION,
            EXPECTED_PAYMENT,
            BULK_ERROR,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                PAYMENT_ORDER -> Value.PAYMENT_ORDER
                LEDGER_TRANSACTION -> Value.LEDGER_TRANSACTION
                TRANSACTION -> Value.TRANSACTION
                EXPECTED_PAYMENT -> Value.EXPECTED_PAYMENT
                BULK_ERROR -> Value.BULK_ERROR
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                PAYMENT_ORDER -> Known.PAYMENT_ORDER
                LEDGER_TRANSACTION -> Known.LEDGER_TRANSACTION
                TRANSACTION -> Known.TRANSACTION
                EXPECTED_PAYMENT -> Known.EXPECTED_PAYMENT
                BULK_ERROR -> Known.BULK_ERROR
                else -> throw ModernTreasuryInvalidDataException("Unknown EntityType: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }

    /**
     * An optional object that contains the provided input params for the request that created this
     * result. This is an item in the `resources` array for the bulk_request
     */
    @JsonDeserialize(builder = RequestParams.Builder::class)
    @NoAutoDetect
    class RequestParams
    private constructor(
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        private var validated: Boolean = false

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun validate(): RequestParams = apply {
            if (!validated) {
                validated = true
            }
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            fun builder() = Builder()
        }

        class Builder {

            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(requestParams: RequestParams) = apply {
                additionalProperties(requestParams.additionalProperties)
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): RequestParams = RequestParams(additionalProperties.toImmutable())
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is RequestParams && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() = "RequestParams{additionalProperties=$additionalProperties}"
    }

    class RequestType
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is RequestType && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            val BULK_REQUEST = of("bulk_request")

            fun of(value: String) = RequestType(JsonField.of(value))
        }

        enum class Known {
            BULK_REQUEST,
        }

        enum class Value {
            BULK_REQUEST,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                BULK_REQUEST -> Value.BULK_REQUEST
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                BULK_REQUEST -> Known.BULK_REQUEST
                else -> throw ModernTreasuryInvalidDataException("Unknown RequestType: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }

    class Status
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Status && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            val PENDING = of("pending")

            val SUCCESSFUL = of("successful")

            val FAILED = of("failed")

            fun of(value: String) = Status(JsonField.of(value))
        }

        enum class Known {
            PENDING,
            SUCCESSFUL,
            FAILED,
        }

        enum class Value {
            PENDING,
            SUCCESSFUL,
            FAILED,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                PENDING -> Value.PENDING
                SUCCESSFUL -> Value.SUCCESSFUL
                FAILED -> Value.FAILED
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                PENDING -> Known.PENDING
                SUCCESSFUL -> Known.SUCCESSFUL
                FAILED -> Known.FAILED
                else -> throw ModernTreasuryInvalidDataException("Unknown Status: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is BulkResult && id == other.id && object_ == other.object_ && liveMode == other.liveMode && createdAt == other.createdAt && updatedAt == other.updatedAt && requestId == other.requestId && requestType == other.requestType && status == other.status && requestParams == other.requestParams && entityId == other.entityId && entityType == other.entityType && entity == other.entity && additionalProperties == other.additionalProperties /* spotless:on */
    }

    /* spotless:off */
    private val hashCode: Int by lazy { Objects.hash(id, object_, liveMode, createdAt, updatedAt, requestId, requestType, status, requestParams, entityId, entityType, entity, additionalProperties) }
    /* spotless:on */

    override fun hashCode(): Int = hashCode

    override fun toString() =
        "BulkResult{id=$id, object_=$object_, liveMode=$liveMode, createdAt=$createdAt, updatedAt=$updatedAt, requestId=$requestId, requestType=$requestType, status=$status, requestParams=$requestParams, entityId=$entityId, entityType=$entityType, entity=$entity, additionalProperties=$additionalProperties}"
}
