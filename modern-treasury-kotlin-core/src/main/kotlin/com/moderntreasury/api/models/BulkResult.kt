// File generated from our OpenAPI spec by Stainless.

package com.moderntreasury.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.moderntreasury.api.core.BaseDeserializer
import com.moderntreasury.api.core.BaseSerializer
import com.moderntreasury.api.core.Enum
import com.moderntreasury.api.core.ExcludeMissing
import com.moderntreasury.api.core.JsonField
import com.moderntreasury.api.core.JsonMissing
import com.moderntreasury.api.core.JsonValue
import com.moderntreasury.api.core.allMaxBy
import com.moderntreasury.api.core.checkKnown
import com.moderntreasury.api.core.checkRequired
import com.moderntreasury.api.core.getOrThrow
import com.moderntreasury.api.core.toImmutable
import com.moderntreasury.api.errors.ModernTreasuryInvalidDataException
import java.time.OffsetDateTime
import java.util.Collections
import java.util.Objects

class BulkResult
@JsonCreator(mode = JsonCreator.Mode.DISABLED)
private constructor(
    private val id: JsonField<String>,
    private val createdAt: JsonField<OffsetDateTime>,
    private val entity: JsonField<Entity>,
    private val entityId: JsonField<String>,
    private val entityType: JsonField<EntityType>,
    private val liveMode: JsonField<Boolean>,
    private val object_: JsonField<String>,
    private val requestId: JsonField<String>,
    private val requestParams: JsonField<RequestParams>,
    private val requestType: JsonField<RequestType>,
    private val status: JsonField<Status>,
    private val updatedAt: JsonField<OffsetDateTime>,
    private val additionalProperties: MutableMap<String, JsonValue>,
) {

    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("entity") @ExcludeMissing entity: JsonField<Entity> = JsonMissing.of(),
        @JsonProperty("entity_id") @ExcludeMissing entityId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("entity_type")
        @ExcludeMissing
        entityType: JsonField<EntityType> = JsonMissing.of(),
        @JsonProperty("live_mode") @ExcludeMissing liveMode: JsonField<Boolean> = JsonMissing.of(),
        @JsonProperty("object") @ExcludeMissing object_: JsonField<String> = JsonMissing.of(),
        @JsonProperty("request_id") @ExcludeMissing requestId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("request_params")
        @ExcludeMissing
        requestParams: JsonField<RequestParams> = JsonMissing.of(),
        @JsonProperty("request_type")
        @ExcludeMissing
        requestType: JsonField<RequestType> = JsonMissing.of(),
        @JsonProperty("status") @ExcludeMissing status: JsonField<Status> = JsonMissing.of(),
        @JsonProperty("updated_at")
        @ExcludeMissing
        updatedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
    ) : this(
        id,
        createdAt,
        entity,
        entityId,
        entityType,
        liveMode,
        object_,
        requestId,
        requestParams,
        requestType,
        status,
        updatedAt,
        mutableMapOf(),
    )

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun id(): String = id.getRequired("id")

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

    /**
     * An object with type as indicated by `entity_type`. This is the result object that is
     * generated by performing the requested action on the provided input `request_params`.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun entity(): Entity = entity.getRequired("entity")

    /**
     * Unique identifier for the result entity object.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun entityId(): String = entityId.getRequired("entity_id")

    /**
     * The type of the result entity object. For a successful bulk result, this is the same as the
     * `resource_type` of the bulk request. For a failed bulk result, this is always bulk_error
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun entityType(): EntityType = entityType.getRequired("entity_type")

    /**
     * This field will be true if this object exists in the live environment or false if it exists
     * in the test environment.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun liveMode(): Boolean = liveMode.getRequired("live_mode")

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun object_(): String = object_.getRequired("object")

    /**
     * Unique identifier for the request that created this bulk result. This is the ID of the bulk
     * request when `request_type` is bulk_request
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun requestId(): String = requestId.getRequired("request_id")

    /**
     * An optional object that contains the provided input params for the request that created this
     * result. This is an item in the `resources` array for the bulk_request
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type (e.g. if
     *   the server responded with an unexpected value).
     */
    fun requestParams(): RequestParams? = requestParams.getNullable("request_params")

    /**
     * The type of the request that created this result. bulk_request is the only supported
     * `request_type`
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun requestType(): RequestType = requestType.getRequired("request_type")

    /**
     * One of successful or failed.
     *
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun status(): Status = status.getRequired("status")

    /**
     * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun updatedAt(): OffsetDateTime = updatedAt.getRequired("updated_at")

    /**
     * Returns the raw JSON value of [id].
     *
     * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

    /**
     * Returns the raw JSON value of [createdAt].
     *
     * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("created_at")
    @ExcludeMissing
    fun _createdAt(): JsonField<OffsetDateTime> = createdAt

    /**
     * Returns the raw JSON value of [entity].
     *
     * Unlike [entity], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("entity") @ExcludeMissing fun _entity(): JsonField<Entity> = entity

    /**
     * Returns the raw JSON value of [entityId].
     *
     * Unlike [entityId], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("entity_id") @ExcludeMissing fun _entityId(): JsonField<String> = entityId

    /**
     * Returns the raw JSON value of [entityType].
     *
     * Unlike [entityType], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("entity_type")
    @ExcludeMissing
    fun _entityType(): JsonField<EntityType> = entityType

    /**
     * Returns the raw JSON value of [liveMode].
     *
     * Unlike [liveMode], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("live_mode") @ExcludeMissing fun _liveMode(): JsonField<Boolean> = liveMode

    /**
     * Returns the raw JSON value of [object_].
     *
     * Unlike [object_], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("object") @ExcludeMissing fun _object_(): JsonField<String> = object_

    /**
     * Returns the raw JSON value of [requestId].
     *
     * Unlike [requestId], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("request_id") @ExcludeMissing fun _requestId(): JsonField<String> = requestId

    /**
     * Returns the raw JSON value of [requestParams].
     *
     * Unlike [requestParams], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("request_params")
    @ExcludeMissing
    fun _requestParams(): JsonField<RequestParams> = requestParams

    /**
     * Returns the raw JSON value of [requestType].
     *
     * Unlike [requestType], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("request_type")
    @ExcludeMissing
    fun _requestType(): JsonField<RequestType> = requestType

    /**
     * Returns the raw JSON value of [status].
     *
     * Unlike [status], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("status") @ExcludeMissing fun _status(): JsonField<Status> = status

    /**
     * Returns the raw JSON value of [updatedAt].
     *
     * Unlike [updatedAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("updated_at")
    @ExcludeMissing
    fun _updatedAt(): JsonField<OffsetDateTime> = updatedAt

    @JsonAnySetter
    private fun putAdditionalProperty(key: String, value: JsonValue) {
        additionalProperties.put(key, value)
    }

    @JsonAnyGetter
    @ExcludeMissing
    fun _additionalProperties(): Map<String, JsonValue> =
        Collections.unmodifiableMap(additionalProperties)

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of [BulkResult].
         *
         * The following fields are required:
         * ```kotlin
         * .id()
         * .createdAt()
         * .entity()
         * .entityId()
         * .entityType()
         * .liveMode()
         * .object_()
         * .requestId()
         * .requestParams()
         * .requestType()
         * .status()
         * .updatedAt()
         * ```
         */
        fun builder() = Builder()
    }

    /** A builder for [BulkResult]. */
    class Builder internal constructor() {

        private var id: JsonField<String>? = null
        private var createdAt: JsonField<OffsetDateTime>? = null
        private var entity: JsonField<Entity>? = null
        private var entityId: JsonField<String>? = null
        private var entityType: JsonField<EntityType>? = null
        private var liveMode: JsonField<Boolean>? = null
        private var object_: JsonField<String>? = null
        private var requestId: JsonField<String>? = null
        private var requestParams: JsonField<RequestParams>? = null
        private var requestType: JsonField<RequestType>? = null
        private var status: JsonField<Status>? = null
        private var updatedAt: JsonField<OffsetDateTime>? = null
        private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

        internal fun from(bulkResult: BulkResult) = apply {
            id = bulkResult.id
            createdAt = bulkResult.createdAt
            entity = bulkResult.entity
            entityId = bulkResult.entityId
            entityType = bulkResult.entityType
            liveMode = bulkResult.liveMode
            object_ = bulkResult.object_
            requestId = bulkResult.requestId
            requestParams = bulkResult.requestParams
            requestType = bulkResult.requestType
            status = bulkResult.status
            updatedAt = bulkResult.updatedAt
            additionalProperties = bulkResult.additionalProperties.toMutableMap()
        }

        fun id(id: String) = id(JsonField.of(id))

        /**
         * Sets [Builder.id] to an arbitrary JSON value.
         *
         * You should usually call [Builder.id] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun id(id: JsonField<String>) = apply { this.id = id }

        fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

        /**
         * Sets [Builder.createdAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply { this.createdAt = createdAt }

        /**
         * An object with type as indicated by `entity_type`. This is the result object that is
         * generated by performing the requested action on the provided input `request_params`.
         */
        fun entity(entity: Entity) = entity(JsonField.of(entity))

        /**
         * Sets [Builder.entity] to an arbitrary JSON value.
         *
         * You should usually call [Builder.entity] with a well-typed [Entity] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun entity(entity: JsonField<Entity>) = apply { this.entity = entity }

        /** Alias for calling [entity] with `Entity.ofPaymentOrder(paymentOrder)`. */
        fun entity(paymentOrder: PaymentOrder) = entity(Entity.ofPaymentOrder(paymentOrder))

        /** Alias for calling [entity] with `Entity.ofExpectedPayment(expectedPayment)`. */
        fun entity(expectedPayment: ExpectedPayment) =
            entity(Entity.ofExpectedPayment(expectedPayment))

        /** Alias for calling [entity] with `Entity.ofLedgerTransaction(ledgerTransaction)`. */
        fun entity(ledgerTransaction: LedgerTransaction) =
            entity(Entity.ofLedgerTransaction(ledgerTransaction))

        /** Alias for calling [entity] with `Entity.ofLedgerAccount(ledgerAccount)`. */
        fun entity(ledgerAccount: LedgerAccount) = entity(Entity.ofLedgerAccount(ledgerAccount))

        /** Alias for calling [entity] with `Entity.ofTransaction(transaction)`. */
        fun entity(transaction: Transaction) = entity(Entity.ofTransaction(transaction))

        /** Alias for calling [entity] with `Entity.ofBulkError(bulkError)`. */
        fun entity(bulkError: Entity.BulkError) = entity(Entity.ofBulkError(bulkError))

        /** Unique identifier for the result entity object. */
        fun entityId(entityId: String) = entityId(JsonField.of(entityId))

        /**
         * Sets [Builder.entityId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.entityId] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun entityId(entityId: JsonField<String>) = apply { this.entityId = entityId }

        /**
         * The type of the result entity object. For a successful bulk result, this is the same as
         * the `resource_type` of the bulk request. For a failed bulk result, this is always
         * bulk_error
         */
        fun entityType(entityType: EntityType) = entityType(JsonField.of(entityType))

        /**
         * Sets [Builder.entityType] to an arbitrary JSON value.
         *
         * You should usually call [Builder.entityType] with a well-typed [EntityType] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun entityType(entityType: JsonField<EntityType>) = apply { this.entityType = entityType }

        /**
         * This field will be true if this object exists in the live environment or false if it
         * exists in the test environment.
         */
        fun liveMode(liveMode: Boolean) = liveMode(JsonField.of(liveMode))

        /**
         * Sets [Builder.liveMode] to an arbitrary JSON value.
         *
         * You should usually call [Builder.liveMode] with a well-typed [Boolean] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun liveMode(liveMode: JsonField<Boolean>) = apply { this.liveMode = liveMode }

        fun object_(object_: String) = object_(JsonField.of(object_))

        /**
         * Sets [Builder.object_] to an arbitrary JSON value.
         *
         * You should usually call [Builder.object_] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun object_(object_: JsonField<String>) = apply { this.object_ = object_ }

        /**
         * Unique identifier for the request that created this bulk result. This is the ID of the
         * bulk request when `request_type` is bulk_request
         */
        fun requestId(requestId: String) = requestId(JsonField.of(requestId))

        /**
         * Sets [Builder.requestId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.requestId] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun requestId(requestId: JsonField<String>) = apply { this.requestId = requestId }

        /**
         * An optional object that contains the provided input params for the request that created
         * this result. This is an item in the `resources` array for the bulk_request
         */
        fun requestParams(requestParams: RequestParams?) =
            requestParams(JsonField.ofNullable(requestParams))

        /**
         * Sets [Builder.requestParams] to an arbitrary JSON value.
         *
         * You should usually call [Builder.requestParams] with a well-typed [RequestParams] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun requestParams(requestParams: JsonField<RequestParams>) = apply {
            this.requestParams = requestParams
        }

        /**
         * The type of the request that created this result. bulk_request is the only supported
         * `request_type`
         */
        fun requestType(requestType: RequestType) = requestType(JsonField.of(requestType))

        /**
         * Sets [Builder.requestType] to an arbitrary JSON value.
         *
         * You should usually call [Builder.requestType] with a well-typed [RequestType] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun requestType(requestType: JsonField<RequestType>) = apply {
            this.requestType = requestType
        }

        /** One of successful or failed. */
        fun status(status: Status) = status(JsonField.of(status))

        /**
         * Sets [Builder.status] to an arbitrary JSON value.
         *
         * You should usually call [Builder.status] with a well-typed [Status] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun status(status: JsonField<Status>) = apply { this.status = status }

        fun updatedAt(updatedAt: OffsetDateTime) = updatedAt(JsonField.of(updatedAt))

        /**
         * Sets [Builder.updatedAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.updatedAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun updatedAt(updatedAt: JsonField<OffsetDateTime>) = apply { this.updatedAt = updatedAt }

        fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.clear()
            putAllAdditionalProperties(additionalProperties)
        }

        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
            additionalProperties.put(key, value)
        }

        fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.putAll(additionalProperties)
        }

        fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
            keys.forEach(::removeAdditionalProperty)
        }

        /**
         * Returns an immutable instance of [BulkResult].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```kotlin
         * .id()
         * .createdAt()
         * .entity()
         * .entityId()
         * .entityType()
         * .liveMode()
         * .object_()
         * .requestId()
         * .requestParams()
         * .requestType()
         * .status()
         * .updatedAt()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): BulkResult =
            BulkResult(
                checkRequired("id", id),
                checkRequired("createdAt", createdAt),
                checkRequired("entity", entity),
                checkRequired("entityId", entityId),
                checkRequired("entityType", entityType),
                checkRequired("liveMode", liveMode),
                checkRequired("object_", object_),
                checkRequired("requestId", requestId),
                checkRequired("requestParams", requestParams),
                checkRequired("requestType", requestType),
                checkRequired("status", status),
                checkRequired("updatedAt", updatedAt),
                additionalProperties.toMutableMap(),
            )
    }

    private var validated: Boolean = false

    fun validate(): BulkResult = apply {
        if (validated) {
            return@apply
        }

        id()
        createdAt()
        entity().validate()
        entityId()
        entityType().validate()
        liveMode()
        object_()
        requestId()
        requestParams()?.validate()
        requestType().validate()
        status().validate()
        updatedAt()
        validated = true
    }

    fun isValid(): Boolean =
        try {
            validate()
            true
        } catch (e: ModernTreasuryInvalidDataException) {
            false
        }

    /**
     * Returns a score indicating how many valid values are contained in this object recursively.
     *
     * Used for best match union deserialization.
     */
    internal fun validity(): Int =
        (if (id.asKnown() == null) 0 else 1) +
            (if (createdAt.asKnown() == null) 0 else 1) +
            (entity.asKnown()?.validity() ?: 0) +
            (if (entityId.asKnown() == null) 0 else 1) +
            (entityType.asKnown()?.validity() ?: 0) +
            (if (liveMode.asKnown() == null) 0 else 1) +
            (if (object_.asKnown() == null) 0 else 1) +
            (if (requestId.asKnown() == null) 0 else 1) +
            (requestParams.asKnown()?.validity() ?: 0) +
            (requestType.asKnown()?.validity() ?: 0) +
            (status.asKnown()?.validity() ?: 0) +
            (if (updatedAt.asKnown() == null) 0 else 1)

    /**
     * An object with type as indicated by `entity_type`. This is the result object that is
     * generated by performing the requested action on the provided input `request_params`.
     */
    @JsonDeserialize(using = Entity.Deserializer::class)
    @JsonSerialize(using = Entity.Serializer::class)
    class Entity
    private constructor(
        private val paymentOrder: PaymentOrder? = null,
        private val expectedPayment: ExpectedPayment? = null,
        private val ledgerTransaction: LedgerTransaction? = null,
        private val ledgerAccount: LedgerAccount? = null,
        private val transaction: Transaction? = null,
        private val bulkError: BulkError? = null,
        private val _json: JsonValue? = null,
    ) {

        fun paymentOrder(): PaymentOrder? = paymentOrder

        fun expectedPayment(): ExpectedPayment? = expectedPayment

        fun ledgerTransaction(): LedgerTransaction? = ledgerTransaction

        fun ledgerAccount(): LedgerAccount? = ledgerAccount

        fun transaction(): Transaction? = transaction

        fun bulkError(): BulkError? = bulkError

        fun isPaymentOrder(): Boolean = paymentOrder != null

        fun isExpectedPayment(): Boolean = expectedPayment != null

        fun isLedgerTransaction(): Boolean = ledgerTransaction != null

        fun isLedgerAccount(): Boolean = ledgerAccount != null

        fun isTransaction(): Boolean = transaction != null

        fun isBulkError(): Boolean = bulkError != null

        fun asPaymentOrder(): PaymentOrder = paymentOrder.getOrThrow("paymentOrder")

        fun asExpectedPayment(): ExpectedPayment = expectedPayment.getOrThrow("expectedPayment")

        fun asLedgerTransaction(): LedgerTransaction =
            ledgerTransaction.getOrThrow("ledgerTransaction")

        fun asLedgerAccount(): LedgerAccount = ledgerAccount.getOrThrow("ledgerAccount")

        fun asTransaction(): Transaction = transaction.getOrThrow("transaction")

        fun asBulkError(): BulkError = bulkError.getOrThrow("bulkError")

        fun _json(): JsonValue? = _json

        fun <T> accept(visitor: Visitor<T>): T =
            when {
                paymentOrder != null -> visitor.visitPaymentOrder(paymentOrder)
                expectedPayment != null -> visitor.visitExpectedPayment(expectedPayment)
                ledgerTransaction != null -> visitor.visitLedgerTransaction(ledgerTransaction)
                ledgerAccount != null -> visitor.visitLedgerAccount(ledgerAccount)
                transaction != null -> visitor.visitTransaction(transaction)
                bulkError != null -> visitor.visitBulkError(bulkError)
                else -> visitor.unknown(_json)
            }

        private var validated: Boolean = false

        fun validate(): Entity = apply {
            if (validated) {
                return@apply
            }

            accept(
                object : Visitor<Unit> {
                    override fun visitPaymentOrder(paymentOrder: PaymentOrder) {
                        paymentOrder.validate()
                    }

                    override fun visitExpectedPayment(expectedPayment: ExpectedPayment) {
                        expectedPayment.validate()
                    }

                    override fun visitLedgerTransaction(ledgerTransaction: LedgerTransaction) {
                        ledgerTransaction.validate()
                    }

                    override fun visitLedgerAccount(ledgerAccount: LedgerAccount) {
                        ledgerAccount.validate()
                    }

                    override fun visitTransaction(transaction: Transaction) {
                        transaction.validate()
                    }

                    override fun visitBulkError(bulkError: BulkError) {
                        bulkError.validate()
                    }
                }
            )
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: ModernTreasuryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            accept(
                object : Visitor<Int> {
                    override fun visitPaymentOrder(paymentOrder: PaymentOrder) =
                        paymentOrder.validity()

                    override fun visitExpectedPayment(expectedPayment: ExpectedPayment) =
                        expectedPayment.validity()

                    override fun visitLedgerTransaction(ledgerTransaction: LedgerTransaction) =
                        ledgerTransaction.validity()

                    override fun visitLedgerAccount(ledgerAccount: LedgerAccount) =
                        ledgerAccount.validity()

                    override fun visitTransaction(transaction: Transaction) = transaction.validity()

                    override fun visitBulkError(bulkError: BulkError) = bulkError.validity()

                    override fun unknown(json: JsonValue?) = 0
                }
            )

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Entity &&
                paymentOrder == other.paymentOrder &&
                expectedPayment == other.expectedPayment &&
                ledgerTransaction == other.ledgerTransaction &&
                ledgerAccount == other.ledgerAccount &&
                transaction == other.transaction &&
                bulkError == other.bulkError
        }

        override fun hashCode(): Int =
            Objects.hash(
                paymentOrder,
                expectedPayment,
                ledgerTransaction,
                ledgerAccount,
                transaction,
                bulkError,
            )

        override fun toString(): String =
            when {
                paymentOrder != null -> "Entity{paymentOrder=$paymentOrder}"
                expectedPayment != null -> "Entity{expectedPayment=$expectedPayment}"
                ledgerTransaction != null -> "Entity{ledgerTransaction=$ledgerTransaction}"
                ledgerAccount != null -> "Entity{ledgerAccount=$ledgerAccount}"
                transaction != null -> "Entity{transaction=$transaction}"
                bulkError != null -> "Entity{bulkError=$bulkError}"
                _json != null -> "Entity{_unknown=$_json}"
                else -> throw IllegalStateException("Invalid Entity")
            }

        companion object {

            fun ofPaymentOrder(paymentOrder: PaymentOrder) = Entity(paymentOrder = paymentOrder)

            fun ofExpectedPayment(expectedPayment: ExpectedPayment) =
                Entity(expectedPayment = expectedPayment)

            fun ofLedgerTransaction(ledgerTransaction: LedgerTransaction) =
                Entity(ledgerTransaction = ledgerTransaction)

            fun ofLedgerAccount(ledgerAccount: LedgerAccount) =
                Entity(ledgerAccount = ledgerAccount)

            fun ofTransaction(transaction: Transaction) = Entity(transaction = transaction)

            fun ofBulkError(bulkError: BulkError) = Entity(bulkError = bulkError)
        }

        /** An interface that defines how to map each variant of [Entity] to a value of type [T]. */
        interface Visitor<out T> {

            fun visitPaymentOrder(paymentOrder: PaymentOrder): T

            fun visitExpectedPayment(expectedPayment: ExpectedPayment): T

            fun visitLedgerTransaction(ledgerTransaction: LedgerTransaction): T

            fun visitLedgerAccount(ledgerAccount: LedgerAccount): T

            fun visitTransaction(transaction: Transaction): T

            fun visitBulkError(bulkError: BulkError): T

            /**
             * Maps an unknown variant of [Entity] to a value of type [T].
             *
             * An instance of [Entity] can contain an unknown variant if it was deserialized from
             * data that doesn't match any known variant. For example, if the SDK is on an older
             * version than the API, then the API may respond with new variants that the SDK is
             * unaware of.
             *
             * @throws ModernTreasuryInvalidDataException in the default implementation.
             */
            fun unknown(json: JsonValue?): T {
                throw ModernTreasuryInvalidDataException("Unknown Entity: $json")
            }
        }

        internal class Deserializer : BaseDeserializer<Entity>(Entity::class) {

            override fun ObjectCodec.deserialize(node: JsonNode): Entity {
                val json = JsonValue.fromJsonNode(node)

                val bestMatches =
                    sequenceOf(
                            tryDeserialize(node, jacksonTypeRef<PaymentOrder>())?.let {
                                Entity(paymentOrder = it, _json = json)
                            },
                            tryDeserialize(node, jacksonTypeRef<ExpectedPayment>())?.let {
                                Entity(expectedPayment = it, _json = json)
                            },
                            tryDeserialize(node, jacksonTypeRef<LedgerTransaction>())?.let {
                                Entity(ledgerTransaction = it, _json = json)
                            },
                            tryDeserialize(node, jacksonTypeRef<LedgerAccount>())?.let {
                                Entity(ledgerAccount = it, _json = json)
                            },
                            tryDeserialize(node, jacksonTypeRef<Transaction>())?.let {
                                Entity(transaction = it, _json = json)
                            },
                            tryDeserialize(node, jacksonTypeRef<BulkError>())?.let {
                                Entity(bulkError = it, _json = json)
                            },
                        )
                        .filterNotNull()
                        .allMaxBy { it.validity() }
                        .toList()
                return when (bestMatches.size) {
                    // This can happen if what we're deserializing is completely incompatible with
                    // all the possible variants (e.g. deserializing from boolean).
                    0 -> Entity(_json = json)
                    1 -> bestMatches.single()
                    // If there's more than one match with the highest validity, then use the first
                    // completely valid match, or simply the first match if none are completely
                    // valid.
                    else -> bestMatches.firstOrNull { it.isValid() } ?: bestMatches.first()
                }
            }
        }

        internal class Serializer : BaseSerializer<Entity>(Entity::class) {

            override fun serialize(
                value: Entity,
                generator: JsonGenerator,
                provider: SerializerProvider,
            ) {
                when {
                    value.paymentOrder != null -> generator.writeObject(value.paymentOrder)
                    value.expectedPayment != null -> generator.writeObject(value.expectedPayment)
                    value.ledgerTransaction != null ->
                        generator.writeObject(value.ledgerTransaction)
                    value.ledgerAccount != null -> generator.writeObject(value.ledgerAccount)
                    value.transaction != null -> generator.writeObject(value.transaction)
                    value.bulkError != null -> generator.writeObject(value.bulkError)
                    value._json != null -> generator.writeObject(value._json)
                    else -> throw IllegalStateException("Invalid Entity")
                }
            }
        }

        class BulkError
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val id: JsonField<String>,
            private val createdAt: JsonField<OffsetDateTime>,
            private val liveMode: JsonField<Boolean>,
            private val object_: JsonField<String>,
            private val requestErrors: JsonField<List<RequestError>>,
            private val updatedAt: JsonField<OffsetDateTime>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
                @JsonProperty("created_at")
                @ExcludeMissing
                createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("live_mode")
                @ExcludeMissing
                liveMode: JsonField<Boolean> = JsonMissing.of(),
                @JsonProperty("object")
                @ExcludeMissing
                object_: JsonField<String> = JsonMissing.of(),
                @JsonProperty("request_errors")
                @ExcludeMissing
                requestErrors: JsonField<List<RequestError>> = JsonMissing.of(),
                @JsonProperty("updated_at")
                @ExcludeMissing
                updatedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            ) : this(id, createdAt, liveMode, object_, requestErrors, updatedAt, mutableMapOf())

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

            /**
             * This field will be true if this object exists in the live environment or false if it
             * exists in the test environment.
             *
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun liveMode(): Boolean = liveMode.getRequired("live_mode")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun object_(): String = object_.getRequired("object")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun requestErrors(): List<RequestError> = requestErrors.getRequired("request_errors")

            /**
             * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected type
             *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun updatedAt(): OffsetDateTime = updatedAt.getRequired("updated_at")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [createdAt].
             *
             * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("created_at")
            @ExcludeMissing
            fun _createdAt(): JsonField<OffsetDateTime> = createdAt

            /**
             * Returns the raw JSON value of [liveMode].
             *
             * Unlike [liveMode], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("live_mode")
            @ExcludeMissing
            fun _liveMode(): JsonField<Boolean> = liveMode

            /**
             * Returns the raw JSON value of [object_].
             *
             * Unlike [object_], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("object") @ExcludeMissing fun _object_(): JsonField<String> = object_

            /**
             * Returns the raw JSON value of [requestErrors].
             *
             * Unlike [requestErrors], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("request_errors")
            @ExcludeMissing
            fun _requestErrors(): JsonField<List<RequestError>> = requestErrors

            /**
             * Returns the raw JSON value of [updatedAt].
             *
             * Unlike [updatedAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("updated_at")
            @ExcludeMissing
            fun _updatedAt(): JsonField<OffsetDateTime> = updatedAt

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BulkError].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .id()
                 * .createdAt()
                 * .liveMode()
                 * .object_()
                 * .requestErrors()
                 * .updatedAt()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [BulkError]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var createdAt: JsonField<OffsetDateTime>? = null
                private var liveMode: JsonField<Boolean>? = null
                private var object_: JsonField<String>? = null
                private var requestErrors: JsonField<MutableList<RequestError>>? = null
                private var updatedAt: JsonField<OffsetDateTime>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(bulkError: BulkError) = apply {
                    id = bulkError.id
                    createdAt = bulkError.createdAt
                    liveMode = bulkError.liveMode
                    object_ = bulkError.object_
                    requestErrors = bulkError.requestErrors.map { it.toMutableList() }
                    updatedAt = bulkError.updatedAt
                    additionalProperties = bulkError.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

                /**
                 * Sets [Builder.createdAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                    this.createdAt = createdAt
                }

                /**
                 * This field will be true if this object exists in the live environment or false if
                 * it exists in the test environment.
                 */
                fun liveMode(liveMode: Boolean) = liveMode(JsonField.of(liveMode))

                /**
                 * Sets [Builder.liveMode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.liveMode] with a well-typed [Boolean] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun liveMode(liveMode: JsonField<Boolean>) = apply { this.liveMode = liveMode }

                fun object_(object_: String) = object_(JsonField.of(object_))

                /**
                 * Sets [Builder.object_] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.object_] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun object_(object_: JsonField<String>) = apply { this.object_ = object_ }

                fun requestErrors(requestErrors: List<RequestError>) =
                    requestErrors(JsonField.of(requestErrors))

                /**
                 * Sets [Builder.requestErrors] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.requestErrors] with a well-typed
                 * `List<RequestError>` value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun requestErrors(requestErrors: JsonField<List<RequestError>>) = apply {
                    this.requestErrors = requestErrors.map { it.toMutableList() }
                }

                /**
                 * Adds a single [RequestError] to [requestErrors].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addRequestError(requestError: RequestError) = apply {
                    requestErrors =
                        (requestErrors ?: JsonField.of(mutableListOf())).also {
                            checkKnown("requestErrors", it).add(requestError)
                        }
                }

                fun updatedAt(updatedAt: OffsetDateTime) = updatedAt(JsonField.of(updatedAt))

                /**
                 * Sets [Builder.updatedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.updatedAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun updatedAt(updatedAt: JsonField<OffsetDateTime>) = apply {
                    this.updatedAt = updatedAt
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [BulkError].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .id()
                 * .createdAt()
                 * .liveMode()
                 * .object_()
                 * .requestErrors()
                 * .updatedAt()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): BulkError =
                    BulkError(
                        checkRequired("id", id),
                        checkRequired("createdAt", createdAt),
                        checkRequired("liveMode", liveMode),
                        checkRequired("object_", object_),
                        checkRequired("requestErrors", requestErrors).map { it.toImmutable() },
                        checkRequired("updatedAt", updatedAt),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): BulkError = apply {
                if (validated) {
                    return@apply
                }

                id()
                createdAt()
                liveMode()
                object_()
                requestErrors().forEach { it.validate() }
                updatedAt()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: ModernTreasuryInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (id.asKnown() == null) 0 else 1) +
                    (if (createdAt.asKnown() == null) 0 else 1) +
                    (if (liveMode.asKnown() == null) 0 else 1) +
                    (if (object_.asKnown() == null) 0 else 1) +
                    (requestErrors.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (if (updatedAt.asKnown() == null) 0 else 1)

            class RequestError
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val code: JsonField<String>,
                private val message: JsonField<String>,
                private val parameter: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("code")
                    @ExcludeMissing
                    code: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("message")
                    @ExcludeMissing
                    message: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("parameter")
                    @ExcludeMissing
                    parameter: JsonField<String> = JsonMissing.of(),
                ) : this(code, message, parameter, mutableMapOf())

                /**
                 * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected
                 *   type (e.g. if the server responded with an unexpected value).
                 */
                fun code(): String? = code.getNullable("code")

                /**
                 * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected
                 *   type (e.g. if the server responded with an unexpected value).
                 */
                fun message(): String? = message.getNullable("message")

                /**
                 * @throws ModernTreasuryInvalidDataException if the JSON field has an unexpected
                 *   type (e.g. if the server responded with an unexpected value).
                 */
                fun parameter(): String? = parameter.getNullable("parameter")

                /**
                 * Returns the raw JSON value of [code].
                 *
                 * Unlike [code], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("code") @ExcludeMissing fun _code(): JsonField<String> = code

                /**
                 * Returns the raw JSON value of [message].
                 *
                 * Unlike [message], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("message") @ExcludeMissing fun _message(): JsonField<String> = message

                /**
                 * Returns the raw JSON value of [parameter].
                 *
                 * Unlike [parameter], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("parameter")
                @ExcludeMissing
                fun _parameter(): JsonField<String> = parameter

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /** Returns a mutable builder for constructing an instance of [RequestError]. */
                    fun builder() = Builder()
                }

                /** A builder for [RequestError]. */
                class Builder internal constructor() {

                    private var code: JsonField<String> = JsonMissing.of()
                    private var message: JsonField<String> = JsonMissing.of()
                    private var parameter: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(requestError: RequestError) = apply {
                        code = requestError.code
                        message = requestError.message
                        parameter = requestError.parameter
                        additionalProperties = requestError.additionalProperties.toMutableMap()
                    }

                    fun code(code: String) = code(JsonField.of(code))

                    /**
                     * Sets [Builder.code] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.code] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun code(code: JsonField<String>) = apply { this.code = code }

                    fun message(message: String) = message(JsonField.of(message))

                    /**
                     * Sets [Builder.message] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.message] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun message(message: JsonField<String>) = apply { this.message = message }

                    fun parameter(parameter: String) = parameter(JsonField.of(parameter))

                    /**
                     * Sets [Builder.parameter] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.parameter] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun parameter(parameter: JsonField<String>) = apply {
                        this.parameter = parameter
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [RequestError].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     */
                    fun build(): RequestError =
                        RequestError(code, message, parameter, additionalProperties.toMutableMap())
                }

                private var validated: Boolean = false

                fun validate(): RequestError = apply {
                    if (validated) {
                        return@apply
                    }

                    code()
                    message()
                    parameter()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: ModernTreasuryInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (code.asKnown() == null) 0 else 1) +
                        (if (message.asKnown() == null) 0 else 1) +
                        (if (parameter.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is RequestError &&
                        code == other.code &&
                        message == other.message &&
                        parameter == other.parameter &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(code, message, parameter, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "RequestError{code=$code, message=$message, parameter=$parameter, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is BulkError &&
                    id == other.id &&
                    createdAt == other.createdAt &&
                    liveMode == other.liveMode &&
                    object_ == other.object_ &&
                    requestErrors == other.requestErrors &&
                    updatedAt == other.updatedAt &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    id,
                    createdAt,
                    liveMode,
                    object_,
                    requestErrors,
                    updatedAt,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkError{id=$id, createdAt=$createdAt, liveMode=$liveMode, object_=$object_, requestErrors=$requestErrors, updatedAt=$updatedAt, additionalProperties=$additionalProperties}"
        }
    }

    /**
     * The type of the result entity object. For a successful bulk result, this is the same as the
     * `resource_type` of the bulk request. For a failed bulk result, this is always bulk_error
     */
    class EntityType @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val PAYMENT_ORDER = of("payment_order")

            val LEDGER_ACCOUNT = of("ledger_account")

            val LEDGER_TRANSACTION = of("ledger_transaction")

            val EXPECTED_PAYMENT = of("expected_payment")

            val TRANSACTION = of("transaction")

            val ENTITY_LINK = of("entity_link")

            val TRANSACTION_LINE_ITEM = of("transaction_line_item")

            val BULK_ERROR = of("bulk_error")

            fun of(value: String) = EntityType(JsonField.of(value))
        }

        /** An enum containing [EntityType]'s known values. */
        enum class Known {
            PAYMENT_ORDER,
            LEDGER_ACCOUNT,
            LEDGER_TRANSACTION,
            EXPECTED_PAYMENT,
            TRANSACTION,
            ENTITY_LINK,
            TRANSACTION_LINE_ITEM,
            BULK_ERROR,
        }

        /**
         * An enum containing [EntityType]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [EntityType] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            PAYMENT_ORDER,
            LEDGER_ACCOUNT,
            LEDGER_TRANSACTION,
            EXPECTED_PAYMENT,
            TRANSACTION,
            ENTITY_LINK,
            TRANSACTION_LINE_ITEM,
            BULK_ERROR,
            /**
             * An enum member indicating that [EntityType] was instantiated with an unknown value.
             */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                PAYMENT_ORDER -> Value.PAYMENT_ORDER
                LEDGER_ACCOUNT -> Value.LEDGER_ACCOUNT
                LEDGER_TRANSACTION -> Value.LEDGER_TRANSACTION
                EXPECTED_PAYMENT -> Value.EXPECTED_PAYMENT
                TRANSACTION -> Value.TRANSACTION
                ENTITY_LINK -> Value.ENTITY_LINK
                TRANSACTION_LINE_ITEM -> Value.TRANSACTION_LINE_ITEM
                BULK_ERROR -> Value.BULK_ERROR
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                PAYMENT_ORDER -> Known.PAYMENT_ORDER
                LEDGER_ACCOUNT -> Known.LEDGER_ACCOUNT
                LEDGER_TRANSACTION -> Known.LEDGER_TRANSACTION
                EXPECTED_PAYMENT -> Known.EXPECTED_PAYMENT
                TRANSACTION -> Known.TRANSACTION
                ENTITY_LINK -> Known.ENTITY_LINK
                TRANSACTION_LINE_ITEM -> Known.TRANSACTION_LINE_ITEM
                BULK_ERROR -> Known.BULK_ERROR
                else -> throw ModernTreasuryInvalidDataException("Unknown EntityType: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value does not have
         *   the expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw ModernTreasuryInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): EntityType = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: ModernTreasuryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is EntityType && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /**
     * An optional object that contains the provided input params for the request that created this
     * result. This is an item in the `resources` array for the bulk_request
     */
    class RequestParams
    @JsonCreator
    private constructor(
        @com.fasterxml.jackson.annotation.JsonValue
        private val additionalProperties: Map<String, JsonValue>
    ) {

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        companion object {

            /** Returns a mutable builder for constructing an instance of [RequestParams]. */
            fun builder() = Builder()
        }

        /** A builder for [RequestParams]. */
        class Builder internal constructor() {

            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(requestParams: RequestParams) = apply {
                additionalProperties = requestParams.additionalProperties.toMutableMap()
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [RequestParams].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             */
            fun build(): RequestParams = RequestParams(additionalProperties.toImmutable())
        }

        private var validated: Boolean = false

        fun validate(): RequestParams = apply {
            if (validated) {
                return@apply
            }

            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: ModernTreasuryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is RequestParams && additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy { Objects.hash(additionalProperties) }

        override fun hashCode(): Int = hashCode

        override fun toString() = "RequestParams{additionalProperties=$additionalProperties}"
    }

    /**
     * The type of the request that created this result. bulk_request is the only supported
     * `request_type`
     */
    class RequestType @JsonCreator private constructor(private val value: JsonField<String>) :
        Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val BULK_REQUEST = of("bulk_request")

            fun of(value: String) = RequestType(JsonField.of(value))
        }

        /** An enum containing [RequestType]'s known values. */
        enum class Known {
            BULK_REQUEST
        }

        /**
         * An enum containing [RequestType]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [RequestType] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            BULK_REQUEST,
            /**
             * An enum member indicating that [RequestType] was instantiated with an unknown value.
             */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                BULK_REQUEST -> Value.BULK_REQUEST
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                BULK_REQUEST -> Known.BULK_REQUEST
                else -> throw ModernTreasuryInvalidDataException("Unknown RequestType: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value does not have
         *   the expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw ModernTreasuryInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): RequestType = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: ModernTreasuryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is RequestType && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /** One of successful or failed. */
    class Status @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val PENDING = of("pending")

            val SUCCESSFUL = of("successful")

            val FAILED = of("failed")

            fun of(value: String) = Status(JsonField.of(value))
        }

        /** An enum containing [Status]'s known values. */
        enum class Known {
            PENDING,
            SUCCESSFUL,
            FAILED,
        }

        /**
         * An enum containing [Status]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Status] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            PENDING,
            SUCCESSFUL,
            FAILED,
            /** An enum member indicating that [Status] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                PENDING -> Value.PENDING
                SUCCESSFUL -> Value.SUCCESSFUL
                FAILED -> Value.FAILED
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                PENDING -> Known.PENDING
                SUCCESSFUL -> Known.SUCCESSFUL
                FAILED -> Known.FAILED
                else -> throw ModernTreasuryInvalidDataException("Unknown Status: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws ModernTreasuryInvalidDataException if this class instance's value does not have
         *   the expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw ModernTreasuryInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): Status = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: ModernTreasuryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Status && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is BulkResult &&
            id == other.id &&
            createdAt == other.createdAt &&
            entity == other.entity &&
            entityId == other.entityId &&
            entityType == other.entityType &&
            liveMode == other.liveMode &&
            object_ == other.object_ &&
            requestId == other.requestId &&
            requestParams == other.requestParams &&
            requestType == other.requestType &&
            status == other.status &&
            updatedAt == other.updatedAt &&
            additionalProperties == other.additionalProperties
    }

    private val hashCode: Int by lazy {
        Objects.hash(
            id,
            createdAt,
            entity,
            entityId,
            entityType,
            liveMode,
            object_,
            requestId,
            requestParams,
            requestType,
            status,
            updatedAt,
            additionalProperties,
        )
    }

    override fun hashCode(): Int = hashCode

    override fun toString() =
        "BulkResult{id=$id, createdAt=$createdAt, entity=$entity, entityId=$entityId, entityType=$entityType, liveMode=$liveMode, object_=$object_, requestId=$requestId, requestParams=$requestParams, requestType=$requestType, status=$status, updatedAt=$updatedAt, additionalProperties=$additionalProperties}"
}
